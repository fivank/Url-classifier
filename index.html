<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Page Classifier & History</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* --- Base Styles --- */
        :root {
            --primary: #2563eb;
            --primary-dark: #1d4ed8;
            --primary-light: #dbeafe;
            --success: #10b981;
            --success-dark: #047857;
            --success-light: #d1fae5;
            --danger: #ef4444;
            --danger-dark: #b91c1c;
            --danger-light: #fee2e2;
            --warning: #f59e0b; /* Added for create folder icon */
            --warning-dark: #b45309;
            --neutral-50: #f9fafb;
            --neutral-100: #f3f4f6;
            --neutral-200: #e5e7eb;
            --neutral-300: #d1d5db;
            --neutral-400: #9ca3af;
            --neutral-500: #6b7280;
            --neutral-600: #4b5563;
            --neutral-700: #374151;
            --neutral-800: #1f2937;
            --neutral-900: #111827;
            --info-light: #dbeafe;
            --info-dark: #1e3a8a;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.1);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1);
            --radius-sm: 0.25rem;
            --radius: 0.5rem;
            --radius-md: 0.75rem;
            --radius-lg: 1rem;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            background-color: var(--neutral-100);
            color: var(--neutral-800);
            padding: 20px;
            font-size: 16px;
        }

        .main-wrapper {
            background-color: #ffffff;
            padding: 0;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
            width: 100%;
            max-width: 900px;
            margin: 0 auto;
            overflow: hidden;
            position: relative;
            transition: box-shadow 0.3s ease;
        }

        .main-wrapper:hover {
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }

        /* --- Header --- */
        h1 {
            text-align: center;
            font-size: 1.8em;
            padding: 1.5rem 0;
            color: var(--primary);
            font-weight: 700;
            margin-bottom: 0;
            background-color: white;
            border-bottom: 1px solid var(--neutral-200);
        }

        h2 {
            font-size: 1.3em;
            margin-bottom: 1rem;
            text-align: left;
            color: var(--neutral-800);
            font-weight: 600;
        }

        /* --- Tab Navigation --- */
        .tab-container {
            display: flex;
            background-color: white;
            border-bottom: 1px solid var(--neutral-200);
            padding: 0 1rem;
        }

        .tab-button {
            padding: 1rem 1.25rem;
            cursor: pointer;
            border: none;
            background-color: transparent;
            font-size: 1rem;
            font-weight: 500;
            color: var(--neutral-600);
            transition: all 0.2s ease;
            border-bottom: 3px solid transparent;
            position: relative;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tab-button:hover {
            color: var(--primary);
            background-color: var(--neutral-50);
        }

        .tab-button.active {
            color: var(--primary);
            border-bottom: 3px solid var(--primary);
        }

        .tab-button.active::after {
            content: "";
            position: absolute;
            bottom: -3px;
            left: 0;
            right: 0;
            height: 3px;
            background-color: var(--primary);
            border-radius: 3px 3px 0 0;
        }

        .tab-button i {
            font-size: 0.9rem;
        }

        /* --- Page Content --- */
        .page-content {
            display: none;
            padding: 2rem;
            animation: fadeIn 0.3s ease;
        }

        .page-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* --- Form Elements --- */
        .form-group {
            margin-bottom: 1.5rem;
            text-align: left;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--neutral-700);
            font-size: 0.95rem;
        }

        input[type="url"], input[type="text"].rename-input {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 1px solid var(--neutral-300);
            border-radius: var(--radius);
            font-size: 1rem;
            font-family: inherit;
            transition: all 0.2s ease;
            background-color: white;
        }

        input[type="url"]:focus, input[type="text"].rename-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.15);
        }

        input[type="url"]::placeholder {
            color: var(--neutral-400);
        }

        button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 0.75rem 1.25rem;
            border-radius: var(--radius);
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        button:hover {
            background-color: var(--primary-dark);
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background-color: var(--neutral-400);
            cursor: not-allowed;
            transform: none;
        }

        button#classifyButton {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 150px;
            width: 100%;
        }

        /* Style for delete/action buttons in history and tree */
        .action-button {
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 0.1rem 0.3rem; /* Smaller padding */
            font-size: 0.85em; /* Slightly smaller icon */
            line-height: 1;
            margin-left: 0.3rem;
            vertical-align: middle;
        }
        .action-button.delete-button { color: var(--danger); }
        .action-button.delete-button:hover { color: var(--danger-dark); }
        .action-button.rename-icon { color: var(--neutral-500); }
        .action-button.rename-icon:hover { color: var(--primary); }
        .action-button.create-folder-icon { color: var(--warning); } /* New icon style */
        .action-button.create-folder-icon:hover { color: var(--warning-dark); }
        .action-button.save-rename { color: var(--success); }
        .action-button.save-rename:hover { color: var(--success-dark); }
        .action-button.cancel-rename { color: var(--neutral-600); }
        .action-button.cancel-rename:hover { color: var(--neutral-800); }

        /* Container for inline rename controls */
        .rename-controls {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            /* Adjust width carefully if needed, might overlap action buttons */
            max-width: calc(100% - 80px); /* Example adjustment */
            margin-left: 0.5rem;
        }
        .rename-controls input.rename-input {
            flex-grow: 1;
            font-size: 0.9em;
            padding: 0.3rem 0.5rem;
        }
        .rename-controls .action-button {
             margin-left: 0.1rem;
        }

        /* --- Loader --- */
        .loader {
            border: 3px solid rgba(255,255,255,0.3);
            border-top: 3px solid white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            animation: spin 1s linear infinite;
            display: none;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* --- Info Boxes --- */
        .info {
            background-color: var(--info-light);
            color: var(--info-dark);
            border-left: 4px solid var(--primary);
            padding: 1rem;
            border-radius: var(--radius-sm);
            margin-bottom: 1.5rem;
            text-align: left;
            font-size: 0.95rem;
        }
        .info i { /* Ensure icons in info box align */
           vertical-align: middle;
           margin: 0 0.1em;
        }

        /* --- Result Display --- */
        .result-display-area {
            margin-top: 1.5rem;
            padding: 1.5rem;
            background-color: white;
            border-radius: var(--radius);
            border: 1px solid var(--neutral-200);
            text-align: left;
            word-wrap: break-word;
            display: none;
            font-size: 0.95em;
            min-height: 100px;
            box-shadow: var(--shadow-sm);
            transition: all 0.3s ease;
        }

        .result-display-area.error {
            background-color: var(--danger-light);
            color: var(--danger);
            border-left: 4px solid var(--danger);
        }

        .result-display-area strong.title {
            display: block;
            margin-bottom: 0.75rem;
            color: var(--primary);
            font-weight: 600;
            font-size: 1.1rem;
            border-bottom: 1px solid var(--neutral-200);
            padding-bottom: 0.75rem;
        }

        .result-display-area.error strong.title {
            color: var(--danger);
        }

        .result-display-area pre {
            background-color: var(--neutral-50);
            padding: 1rem;
            border-radius: var(--radius-sm);
            border: 1px solid var(--neutral-200);
            font-family: Monaco, Menlo, Consolas, "Liberation Mono", monospace;
            white-space: pre-wrap;
            word-break: break-all;
            font-size: 0.9rem;
            margin: 0;
            color: var(--neutral-800);
            overflow-x: auto;
            max-height: 400px;
            overflow-y: auto;
        }

        .result-display-area.error pre {
            color: var(--danger);
            background-color: transparent;
            border: none;
            padding: 0;
            white-space: pre-wrap;
            font-family: inherit;
            font-size: 1em;
        }

        /* --- History List --- */
        #historyList {
            list-style: none;
            padding: 0;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--neutral-200);
            border-radius: var(--radius);
            margin-bottom: 1rem;
            background-color: white;
        }

        #historyList li {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--neutral-200);
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            transition: background-color 0.2s ease;
            color: var(--neutral-700);
        }

        #historyList li:last-child {
            border-bottom: none;
        }

        #historyList li:hover {
            background-color: var(--neutral-100);
        }

        #historyList li.selected {
            background-color: var(--primary-light);
            color: var(--primary-dark);
            font-weight: 500;
            border-left: 4px solid var(--primary);
        }

        /* Ensure delete button aligns correctly in list */
        #historyList .action-button.delete-button {
            margin-left: auto; /* Push delete button to the right */
            padding-left: 0.5rem; /* Add some space */
        }

        /* --- History Actions --- */
        .history-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            gap: 0.75rem;
        }

        .history-actions button {
            margin-top: 0;
            padding: 0.75rem 1rem;
            font-size: 0.9rem;
            flex-shrink: 0;
        }

        #showAllButton {
            background-color: var(--success);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        #showAllButton:hover {
            background-color: #0d9488;
        }

        #clearHistoryButton {
            background-color: var(--danger);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        #clearHistoryButton:hover {
            background-color: #b91c1c;
        }

        /* --- URL Tree --- */
        #urlTreeContainer {
            font-size: 0.95rem;
            border: 1px solid var(--neutral-200);
            padding: 1.5rem;
            border-radius: var(--radius);
            max-height: 500px;
            overflow: auto;
            background-color: white;
            box-shadow: var(--shadow-sm);
        }

        #urlTreeContainer ul {
            list-style: none;
            padding-left: 1.5rem;
            margin-top: 0.5rem;
        }

        #urlTreeContainer li {
            margin-bottom: 0.5rem;
            position: relative;
        }

        /* Folder toggle icon */
        .toggle-icon {
            cursor: pointer;
            margin-right: 0.5rem;
            width: 1em; /* Ensure consistent width */
            display: inline-block;
            text-align: center;
        }

        #urlTreeContainer li::before {
            content: "";
            position: absolute;
            left: -1rem;
            top: 0.7rem; /* Adjust if needed */
            width: 0.5rem;
            height: 0;
            border-top: 1px solid var(--neutral-300);
        }

        #urlTreeContainer ul > li::after {
            content: "";
            position: absolute;
            left: -1rem;
            top: 0;
            height: 100%;
            border-left: 1px solid var(--neutral-300);
        }

        #urlTreeContainer ul > li:last-child::after {
            height: 0.7rem; /* Adjust vertical line height for last item */
        }

        /* Style for category labels (potential drop targets) */
        #urlTreeContainer .category-label {
            font-weight: 600;
            color: var(--neutral-700);
            display: inline-flex;
            align-items: center;
            margin-bottom: 0.3rem;
            padding: 0.25rem 0.5rem;
            position: relative;
            width: 100%;
            border-radius: var(--radius-sm);
            transition: background-color 0.2s ease, border 0.2s ease;
            border: 1px solid transparent;
        }
        /* Prevent text/icons interfering with drop/click */
        #urlTreeContainer .category-label > .label-text,
        #urlTreeContainer .category-label .folder-icon {
             pointer-events: none;
        }
        #urlTreeContainer .category-label > .label-text {
             margin-right: 5px;
        }
        /* Style for drop zone indication */
        #urlTreeContainer .category-label.drag-over {
            background-color: var(--primary-light);
            border: 1px dashed var(--primary);
        }
        /* Container for action buttons on category label */
        .category-actions {
            margin-left: auto; /* Push actions to the right */
            display: inline-flex;
            align-items: center;
        }

        /* Add folder icon using FA class */
        #urlTreeContainer .category-label .folder-icon {
            margin-right: 0.5rem;
            color: var(--primary);
        }

        /* Style for URL links (draggable items) */
        #urlTreeContainer .url-link {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.25rem 0.5rem;
            border-radius: var(--radius-sm);
            transition: opacity 0.2s ease;
            cursor: grab;
        }
        /* Style for when dragging */
         #urlTreeContainer .url-link.dragging {
            opacity: 0.5;
            cursor: grabbing;
            background-color: var(--neutral-200);
        }
        /* Prevent link click during drag */
        #urlTreeContainer .url-link a {
            pointer-events: none;
        }

        #urlTreeContainer .url-link a {
            color: var(--primary);
            text-decoration: none;
            word-break: break-all;
            font-size: 0.9rem;
            display: inline-flex;
            align-items: center;
            margin-right: 5px;
        }

        #urlTreeContainer .url-link a::before {
            content: "\f0c1"; /* link icon */
            font-family: "Font Awesome 6 Free";
            font-weight: 900;
            margin-right: 0.5rem;
            font-size: 0.8rem;
            color: var(--neutral-500);
        }

        #urlTreeContainer .empty-tree {
            font-style: italic;
            color: var(--neutral-500);
            text-align: center;
            padding: 2rem;
        }

        /* Hidden utility class */
        .hidden {
            display: none !important;
        }

        /* --- Responsive Styles --- */
        @media (max-width: 768px) {
            .main-wrapper {
                border-radius: var(--radius);
            }

            .page-content {
                padding: 1.25rem;
            }
            /* Adjust label width more aggressively */
            #urlTreeContainer .category-label > .label-text {
                 max-width: calc(100% - 100px); /* Adjust based on button count */
                 overflow: hidden;
                 text-overflow: ellipsis;
                 white-space: nowrap;
                 display: inline-block; /* Needed for text-overflow */
            }
            #urlTreeContainer .url-link a {
                 max-width: calc(100% - 40px);
            }
        }

        @media (max-width: 600px) {
            body {
                padding: 10px;
            }

            h1 {
                font-size: 1.5rem;
                padding: 1rem 0;
            }

            .tab-button {
                padding: 0.75rem 0.5rem;
                font-size: 0.85rem;
            }

            .tab-container {
                padding: 0;
            }

            .tab-button i {
                margin-right: 0;
            }

            .tab-button span {
                display: none;
            }

            .history-actions {
                flex-direction: column;
            }

            .history-actions button {
                width: 100%;
            }

            #urlTreeContainer ul {
                padding-left: 1rem;
            }

            .result-display-area pre {
                font-size: 0.8rem;
            }
            .rename-controls {
                width: calc(100% - 20px);
            }
             #urlTreeContainer .category-label > .label-text {
                  max-width: calc(100% - 120px); /* Even more aggressive */
             }
             #urlTreeContainer .url-link a {
                  max-width: calc(100% - 50px);
             }
        }
    </style>
</head>
<body>
    <div class="main-wrapper">
        <h1>Web Page Classifier</h1>

        <!-- Tab Navigation -->
        <div class="tab-container">
            <button class="tab-button active" data-target="classifierPage">
                <i class="fas fa-magnifying-glass"></i>
                <span>Classifier</span>
            </button>
            <button class="tab-button" data-target="historyPage">
                <i class="fas fa-clock-rotate-left"></i>
                <span>History</span>
            </button>
            <button class="tab-button" data-target="treePage">
                <i class="fas fa-sitemap"></i>
                <span>URL Tree</span>
            </button>
        </div>

        <!-- Classifier Page Content -->
        <div id="classifierPage" class="page-content active">
             <div class="info">
                <i class="fas fa-circle-info"></i> Enter a URL. The classification result (JSON) will be displayed below and saved to history.
            </div>
            <div class="form-group">
                <label for="pageUrl">Web Page URL:</label>
                <input type="url" id="pageUrl" placeholder="https://example.com/article" required>
            </div>
            <button id="classifyButton">
                <div class="loader" id="loader"></div>
                <span>Classify URL</span>
            </button>
            <div id="classifierResultDisplay" class="result-display-area">
                <strong class="title">Result:</strong>
                <pre></pre>
            </div>
        </div>

        <!-- History Page Content -->
        <div id="historyPage" class="page-content">
            <h2>Classification History List</h2>
            <ul id="historyList"><li></li></ul> <!-- Initial empty li placeholder handled by JS -->
            <div class="history-actions">
                <button id="showAllButton">
                    <i class="fas fa-list"></i>
                    <span>Show All URLs & Classifications</span>
                </button>
                <button id="clearHistoryButton">
                    <i class="fas fa-trash-can"></i>
                    <span>Clear History</span>
                </button>
            </div>
            <div id="historyResultDisplay" class="result-display-area">
                <strong class="title">Selected / All History:</strong>
                <pre></pre>
            </div>
        </div>

        <!-- Tree Page Content -->
        <div id="treePage" class="page-content">
            <h2>URL Classification Tree</h2>
            <div class="info">
                 <i class="fas fa-circle-info"></i> Drag & drop a URL (<i class="fas fa-link"></i>) onto a category (<i class="fas fa-folder"></i>) to move.
                 Click <i class="fas fa-chevron-down"></i>/<i class="fas fa-chevron-right"></i> to fold/unfold.
                 Click <i class="fas fa-pencil-alt"></i> to rename.
                 Click <i class="fas fa-folder-plus"></i> to add a subfolder.
                 Click <i class="fas fa-trash-alt"></i> on a URL to delete.
            </div>
            <div id="urlTreeContainer">
                <!-- Tree will be rendered here by JavaScript -->
            </div>
        </div>

    </div> <!-- End main-wrapper -->

    <script>
        // --- Configuration ---
        const NETLIFY_FUNCTION_ENDPOINT = '/.netlify/functions/classify-url';
        const LOCAL_STORAGE_KEY = 'urlClassificationHistory';
        const DRAG_DATA_TYPE = 'text/plain'; // Data type for drag/drop ID
        const DUMMY_ITEM_PREFIX = 'placeholder://dummy_'; // Prefix for placeholder URLs

        // --- DOM Elements ---
        const classifyButton = document.getElementById('classifyButton');
        const urlInput = document.getElementById('pageUrl');
        const loader = document.getElementById('loader');
        const buttonText = classifyButton.querySelector('span');
        const classifierResultDisplay = document.getElementById('classifierResultDisplay');
        const historyResultDisplay = document.getElementById('historyResultDisplay');
        const historyList = document.getElementById('historyList');
        const clearHistoryButton = document.getElementById('clearHistoryButton');
        const showAllButton = document.getElementById('showAllButton');
        const urlTreeContainer = document.getElementById('urlTreeContainer');
        const tabButtons = document.querySelectorAll('.tab-button');
        const pageContents = document.querySelectorAll('.page-content');

        // --- State ---
        let classificationHistory = []; // In-memory copy
        let draggedElement = null; // Keep track of the element being dragged

        // --- Helper: Generate Unique ID ---
        function generateId(isDummy = false) {
            const randomPart = Math.random().toString(36).substring(2);
            return isDummy ? DUMMY_ITEM_PREFIX + randomPart : Date.now().toString(36) + randomPart;
        }

        // --- Functions ---

        function showLoading(isLoading) { /* ... no changes ... */
            if (isLoading) {
                classifyButton.disabled = true;
                loader.style.display = 'inline-block';
                buttonText.textContent = 'Classifying...';
                classifierResultDisplay.style.display = 'none';
                classifierResultDisplay.classList.remove('error');
            } else {
                classifyButton.disabled = false;
                loader.style.display = 'none';
                buttonText.textContent = 'Classify URL';
            }
        }

        function displayResultInArea(areaElement, data, isError = false, titlePrefix = 'Result') { /* ... no changes ... */
             areaElement.innerHTML = ''; // Clear previous content
            areaElement.style.display = 'block';
            const title = document.createElement('strong');
            title.classList.add('title');
            const resultOutput = document.createElement('pre');
            if (isError) {
                areaElement.classList.add('error');
                title.textContent = `Error:`;
                resultOutput.textContent = (typeof data === 'string') ? data : JSON.stringify(data, null, 2);
            } else {
                areaElement.classList.remove('error');
                title.textContent = `${titlePrefix}:`;
                resultOutput.textContent = JSON.stringify(data, null, 2);
            }
            areaElement.appendChild(title);
            areaElement.appendChild(resultOutput);
        }

        // Delete an entry from history by id
        function deleteHistoryEntryById(entryId) { /* ... no changes ... */
            const initialLength = classificationHistory.length;
            classificationHistory = classificationHistory.filter(entry => entry.id !== entryId);
            if (classificationHistory.length < initialLength) {
                saveHistory();
                renderHistoryList();
                const treeData = buildUrlTree(classificationHistory);
                renderTree(treeData, urlTreeContainer);
                 historyResultDisplay.style.display = 'none';
                 document.querySelectorAll('#historyList li.selected').forEach(el => el.classList.remove('selected'));
                 console.log(`Deleted history entry ${entryId}`);
            } else {
                console.warn(`Attempted to delete non-existent entry ${entryId}`);
            }
        }

        // --- History List Rendering and Management ---

        function renderHistoryList() {
            historyList.innerHTML = '';
            const nonDummyHistory = classificationHistory.filter(item => !item.id.startsWith(DUMMY_ITEM_PREFIX)); // Exclude dummies

            if (nonDummyHistory.length === 0) {
                const emptyLi = document.createElement('li');
                emptyLi.textContent = "No history yet.";
                emptyLi.style.fontStyle = "italic";
                emptyLi.style.color = "var(--neutral-500)";
                emptyLi.style.textAlign = "center";
                emptyLi.style.cursor = "default";
                historyList.appendChild(emptyLi);
                return;
            }

            nonDummyHistory.forEach((item) => {
                const li = document.createElement('li');
                const textSpan = document.createElement('span');
                textSpan.textContent = item.url;
                textSpan.style.overflow = 'hidden';
                textSpan.style.textOverflow = 'ellipsis';
                textSpan.style.whiteSpace = 'nowrap';
                textSpan.title = item.url;
                li.appendChild(textSpan);

                li.dataset.id = item.id;

                const delBtn = document.createElement('button');
                delBtn.classList.add('action-button', 'delete-button');
                delBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
                delBtn.title = "Delete this entry";
                delBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteHistoryEntryById(item.id);
                });
                li.appendChild(delBtn);

                li.addEventListener('click', () => {
                    document.querySelectorAll('#historyList li.selected').forEach(el => el.classList.remove('selected'));
                    li.classList.add('selected');
                    if (item.classification) {
                        displayResultInArea(historyResultDisplay, item.classification, false, `Selected: ${item.url}`);
                    } else {
                        displayResultInArea(historyResultDisplay, "Classification data missing for this entry.", true, `Selected: ${item.url}`);
                    }
                });
                historyList.appendChild(li);
            });
        }

        function loadHistory() { /* ... no changes ... */
            try {
                const storedHistory = localStorage.getItem(LOCAL_STORAGE_KEY);
                classificationHistory = storedHistory ? JSON.parse(storedHistory) : [];
                 if (!Array.isArray(classificationHistory)) {
                     console.warn("Stored history was not an array, resetting.");
                     classificationHistory = [];
                     localStorage.removeItem(LOCAL_STORAGE_KEY);
                 }
            } catch (error) {
                console.error("Error loading/parsing history:", error);
                classificationHistory = [];
            }
            renderHistoryList();
            const treeData = buildUrlTree(classificationHistory);
            renderTree(treeData, urlTreeContainer);
        }

        function saveHistory() { /* ... no changes ... */
             try {
                // Filter out potential null/undefined entries just in case
                const validHistory = classificationHistory.filter(item => item && item.id);
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(validHistory));
                // Update the in-memory array to match what was saved
                classificationHistory = validHistory;
            } catch (error) {
                console.error("Error saving history:", error);
                displayResultInArea(classifierResultDisplay, "Could not save history (Storage might be full).", true);
            }
        }

        function addHistoryEntry(url, classificationData) { /* ... no changes ... */
            const newEntry = { id: generateId(), url: url, classification: classificationData };
            classificationHistory.unshift(newEntry);
            saveHistory();
            renderHistoryList();
            const treeData = buildUrlTree(classificationHistory);
            renderTree(treeData, urlTreeContainer);
        }

        function showAllHistory() {
            const nonDummyHistory = classificationHistory.filter(item => !item.id.startsWith(DUMMY_ITEM_PREFIX));
            if (nonDummyHistory.length === 0) {
                displayResultInArea(historyResultDisplay, "History is empty.", true, "Full History");
            } else {
                 const displayHistory = nonDummyHistory.map(({ id, ...rest }) => rest);
                 displayResultInArea(historyResultDisplay, displayHistory, false, "All Stored Classifications");
            }
            document.querySelectorAll('#historyList li.selected').forEach(el => el.classList.remove('selected'));
        }

        function clearHistory() { /* ... no changes ... */
             if (confirm("Are you sure you want to clear the entire classification history? This cannot be undone.")) {
                classificationHistory = [];
                saveHistory();
                renderHistoryList();
                historyResultDisplay.style.display = 'none';
                urlTreeContainer.innerHTML = '<div class="empty-tree">History cleared.</div>';
            }
        }

        // --- Tree Building and Rendering Logic ---

        // Helper to safely get nested properties
        const get = (obj, path, defaultValue = undefined) => { /* ... no changes ... */
          const travel = (regexp) =>
            String.prototype.split
              .call(path, regexp)
              .filter(Boolean)
              .reduce((res, key) => (res !== null && res !== undefined ? res[key] : res), obj);
          const result = travel(/[,[\]]+?/) || travel(/[,[\].]+?/);
          return result === undefined || result === obj ? defaultValue : result;
        };


        function buildUrlTree(history) { /* ... logic mostly same, ensures _meta/_items */
             const tree = {}; // Root of the tree

            history.forEach(item => {
                // Skip if item or classification is invalid
                 if (!item || !item.id || !item.classification) return;

                const classification = get(item, 'classification.classification');
                if (!classification) return;

                const urlType = classification.url_type || 'Unknown Type';
                const format = classification.content_format || 'Unknown Format';
                const hierarchy = Array.isArray(classification.content_type_hierarchy) && classification.content_type_hierarchy.length > 0
                                  ? classification.content_type_hierarchy
                                  : ['Unknown Category'];

                let currentLevel = tree;
                let parentMetaHierarchy = []; // Track hierarchy for meta

                // Level 1: URL Type
                if (!currentLevel[urlType]) currentLevel[urlType] = { _meta: { urlType: urlType, format: null, hierarchy: [urlType] } }; // Hierarchy includes urlType
                parentMetaHierarchy = currentLevel[urlType]._meta.hierarchy;
                currentLevel = currentLevel[urlType];

                // Level 2: Content Format (Conditional based on 'HTML')
                let formatKey = format;
                let actualFormatForMeta = format;
                let formatSkipped = false;
                if (format.trim().toLowerCase() !== 'html') {
                    if (!currentLevel[formatKey]) currentLevel[formatKey] = { _meta: { urlType: urlType, format: actualFormatForMeta, hierarchy: [...parentMetaHierarchy, formatKey] } };
                    parentMetaHierarchy = currentLevel[formatKey]._meta.hierarchy; // Update parent hierarchy for next level
                    currentLevel = currentLevel[formatKey];
                } else {
                    actualFormatForMeta = 'HTML';
                    formatSkipped = true;
                    // Parent hierarchy remains the urlType's hierarchy
                }

                // Levels 3+: Content Type Hierarchy
                hierarchy.forEach((category, index) => {
                    const isLastLevel = index === hierarchy.length - 1;
                    // Construct the *full* hierarchy path for the meta of the *current* category being processed
                    const currentMetaHierarchy = formatSkipped
                        ? [urlType, ...hierarchy.slice(0, index + 1)]
                        : [urlType, formatKey, ...hierarchy.slice(0, index + 1)];

                     if (!currentLevel[category]) {
                         const meta = {
                             urlType: urlType,
                             format: actualFormatForMeta, // Use the determined format
                             hierarchy: currentMetaHierarchy // Store full path in meta
                         };
                         // Initialize with _items only if it's the last level *and* we are adding a real item
                         currentLevel[category] = isLastLevel && !item.id.startsWith(DUMMY_ITEM_PREFIX)
                             ? { _meta: meta, _items: [] }
                             : { _meta: meta }; // Otherwise, just create the node with meta
                     }

                     // Ensure _items array exists if it's the last level and we're adding a real item
                     if (isLastLevel && !item.id.startsWith(DUMMY_ITEM_PREFIX)) {
                          if (!currentLevel[category]._items) {
                              currentLevel[category]._items = [];
                          }
                          // Add the URL entry object if not already present
                          if (!currentLevel[category]._items.some(entry => entry.id === item.id)) {
                              currentLevel[category]._items.push({ id: item.id, url: item.url });
                          }
                     }

                     // Move down only if not the last level
                     if (!isLastLevel) {
                        currentLevel = currentLevel[category];
                     }
                });
            });
             // console.log("Built Tree:", JSON.stringify(tree, null, 2));
            return tree;
        }


        function renderTree(treeData, containerElement) { /* ... no changes ... */
             containerElement.innerHTML = '';
            if (Object.keys(treeData).length === 0) {
                containerElement.innerHTML = '<div class="empty-tree">No classification data available to build the tree.</div>';
                return;
            }
            const rootUl = document.createElement('ul');
            containerElement.appendChild(rootUl);
            renderTreeNode(treeData, rootUl);
        }

        // Modified renderTreeNode to add Create Folder icon
        function renderTreeNode(node, parentUl) {
            const categories = Object.keys(node).filter(key => key !== '_meta' && key !== '_items').sort();

            categories.forEach(category => {
                const li = document.createElement('li');
                const nodeValue = node[category];
                const meta = nodeValue._meta;
                const items = nodeValue._items || []; // Default to empty array

                const isFolder = Object.keys(nodeValue).some(k => k !== '_meta' && k !== '_items');
                const hasRealItems = items.some(item => !item.id.startsWith(DUMMY_ITEM_PREFIX));
                const hasOnlyDummyItems = items.length > 0 && !hasRealItems;
                const isEmptyFolder = !isFolder && items.length === 0; // Explicitly no subfolders, no items


                 if (!meta) {
                    console.warn("Node missing _meta data:", category, nodeValue);
                    return;
                 }

                // --- Create Header (Drop Target) ---
                const header = document.createElement('div');
                header.classList.add('category-label');
                header.dataset.targetUrlType = meta.urlType;
                header.dataset.targetFormat = meta.format === null ? 'HTML' : meta.format; // Handle null format from meta
                header.dataset.targetHierarchy = JSON.stringify(meta.hierarchy);

                // --- Left side: Toggle, Folder Icon, Label ---
                const toggleIcon = document.createElement('i');
                if (isFolder || items.length > 0) { // Show toggle if it has subfolders OR any items (even dummy)
                   toggleIcon.classList.add('toggle-icon', 'fas', 'fa-chevron-down');
                } else {
                   toggleIcon.classList.add('toggle-icon', 'fas', 'fa-minus');
                   toggleIcon.style.opacity = '0.3';
                   toggleIcon.style.cursor = 'default';
                }

                const iconSpan = document.createElement('i');
                iconSpan.classList.add('fas', 'fa-folder', 'folder-icon');
                const labelSpan = document.createElement('span');
                labelSpan.classList.add('label-text');
                labelSpan.textContent = category;

                header.appendChild(toggleIcon);
                header.appendChild(iconSpan);
                header.appendChild(labelSpan);

                 // --- Right side: Action Buttons Container ---
                 const actionsContainer = document.createElement('div');
                 actionsContainer.classList.add('category-actions');

                 // Rename Icon
                 const renameIcon = document.createElement('button');
                 renameIcon.classList.add('action-button', 'rename-icon');
                 renameIcon.innerHTML = '<i class="fas fa-pencil-alt"></i>';
                 renameIcon.title = `Rename category "${category}"`;
                 renameIcon.dataset.categoryName = category;
                 renameIcon.dataset.fullHierarchyPath = JSON.stringify(meta.hierarchy); // Use meta hierarchy path
                 actionsContainer.appendChild(renameIcon);

                 // Create Subfolder Icon
                 const createFolderIcon = document.createElement('button');
                 createFolderIcon.classList.add('action-button', 'create-folder-icon');
                 createFolderIcon.innerHTML = '<i class="fas fa-folder-plus"></i>';
                 createFolderIcon.title = `Create subfolder in "${category}"`;
                 // Store parent data needed for creation
                 createFolderIcon.dataset.parentUrlType = meta.urlType;
                 createFolderIcon.dataset.parentFormat = meta.format === null ? 'HTML' : meta.format; // Handle null format
                 createFolderIcon.dataset.parentHierarchy = JSON.stringify(meta.hierarchy);
                 actionsContainer.appendChild(createFolderIcon);

                 header.appendChild(actionsContainer); // Add actions container to header

                li.appendChild(header);

                // --- Create Nested List (ul) for Children ---
                let nestedUl = null;
                if (isFolder || items.length > 0) { // Create UL if subfolders OR items exist
                    nestedUl = document.createElement('ul');

                    // Render child categories (folders)
                    if (isFolder) {
                        renderTreeNode(nodeValue, nestedUl);
                    }

                    // Render real items (URLs) directly under this category
                    items.filter(item => !item.id.startsWith(DUMMY_ITEM_PREFIX)) // Exclude dummies from rendering
                         .sort((a, b) => a.url.localeCompare(b.url))
                         .forEach(entry => {
                            const urlLi = document.createElement('li');
                            urlLi.classList.add('url-link');
                            urlLi.draggable = true;
                            urlLi.dataset.entryId = entry.id;

                            const link = document.createElement('a');
                            link.href = entry.url;
                            link.textContent = entry.url;
                            link.title = entry.url;
                            link.target = '_blank';
                            link.rel = 'noopener noreferrer';
                            urlLi.appendChild(link);

                            const deleteBtn = document.createElement('button');
                            deleteBtn.classList.add('action-button', 'delete-button');
                            deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
                            deleteBtn.title = "Delete this URL entry";
                            deleteBtn.addEventListener('click', (e) => {
                                e.stopPropagation();
                                deleteHistoryEntryById(entry.id);
                            });
                            urlLi.appendChild(deleteBtn);
                            nestedUl.appendChild(urlLi);
                        });
                     li.appendChild(nestedUl);

                     // --- Toggle Functionality ---
                     if (toggleIcon.classList.contains('toggle-icon')) {
                         toggleIcon.addEventListener('click', (e) => {
                             e.stopPropagation();
                             const isHidden = nestedUl.style.display === 'none';
                             nestedUl.style.display = isHidden ? 'block' : 'none';
                             toggleIcon.classList.replace(
                                 isHidden ? 'fa-chevron-right' : 'fa-chevron-down',
                                 isHidden ? 'fa-chevron-down' : 'fa-chevron-right'
                             );
                         });
                     } else {
                         // If no toggle icon, ensure children are visible by default (shouldn't happen often)
                         if (nestedUl) nestedUl.style.display = 'block';
                     }
                 }
                 parentUl.appendChild(li);
            });
        }


        // --- Rename Category Logic ---

        function showRenameInput(renameIcon) { /* ... no changes ... */
            const headerDiv = renameIcon.closest('.category-label');
            const labelSpan = headerDiv.querySelector('.label-text');
            const actionsContainer = headerDiv.querySelector('.category-actions'); // Target actions container
            const oldName = renameIcon.dataset.categoryName;

            if (headerDiv.querySelector('.rename-controls')) return;

            // Hide label span and actions container
            labelSpan.classList.add('hidden');
            if (actionsContainer) actionsContainer.classList.add('hidden'); // Hide all actions

            // Create input field
            const input = document.createElement('input'); /* ... */
            input.type = 'text';
            input.value = oldName;
            input.classList.add('rename-input');
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') { handleRenameSave(input); }
                else if (e.key === 'Escape') { handleRenameCancel(input); }
            });

            // Create Save/Cancel buttons
            const saveBtn = document.createElement('button'); /* ... */
            saveBtn.classList.add('action-button', 'save-rename');
            saveBtn.innerHTML = '<i class="fas fa-check"></i>';
            saveBtn.title = 'Save new name';
            saveBtn.addEventListener('click', () => handleRenameSave(input));

            const cancelBtn = document.createElement('button'); /* ... */
            cancelBtn.classList.add('action-button', 'cancel-rename');
            cancelBtn.innerHTML = '<i class="fas fa-times"></i>';
            cancelBtn.title = 'Cancel rename';
            cancelBtn.addEventListener('click', () => handleRenameCancel(input));

            const controls = document.createElement('div');
            controls.classList.add('rename-controls');
            controls.appendChild(input);
            controls.appendChild(saveBtn);
            controls.appendChild(cancelBtn);

            // Insert controls before the hidden label span
            headerDiv.insertBefore(controls, labelSpan);
            input.focus();
            input.select();
        }

        function handleRenameSave(inputElement) { /* ... uses fullHierarchyPath now ... */
            const controlsDiv = inputElement.closest('.rename-controls');
            if (!controlsDiv) return;
            const headerDiv = controlsDiv.closest('.category-label');
            const actionsContainer = headerDiv.querySelector('.category-actions'); // Find original actions
            const renameIcon = actionsContainer?.querySelector('.rename-icon'); // Find icon within actions
             if (!renameIcon) { // Should not happen if UI is correct
                 console.error("Could not find original rename icon data.");
                 handleRenameCancel(inputElement); // Attempt to restore UI
                 return;
             }

            const oldName = renameIcon.dataset.categoryName;
            const fullHierarchyPathString = renameIcon.dataset.fullHierarchyPath; // Uses meta path
            const newName = inputElement.value.trim();

            if (newName && newName !== oldName) {
                 try {
                     const fullHierarchyPath = JSON.parse(fullHierarchyPathString);
                     if (renameCategoryInData(fullHierarchyPath, oldName, newName)) { // Call updated function
                        console.log(`Renamed category based on path [${fullHierarchyPath.join('/')}] to "${newName}"`);
                        const treeData = buildUrlTree(classificationHistory);
                        renderTree(treeData, urlTreeContainer); // Re-render handles UI cleanup
                     } else {
                        console.error("Rename function reported no changes made.");
                        handleRenameCancel(inputElement); // Restore UI if data update failed
                     }
                 } catch (e) {
                     console.error("Error parsing path or renaming:", e);
                     handleRenameCancel(inputElement);
                 }
            } else {
                handleRenameCancel(inputElement); // Treat no change or empty name as cancel
            }
        }

        function handleRenameCancel(inputElement) { /* ... ensures actions container is shown ... */
            const controlsDiv = inputElement.closest('.rename-controls');
             if (!controlsDiv) return;
            const headerDiv = controlsDiv.closest('.category-label');
            const labelSpan = headerDiv.querySelector('.label-text');
            const actionsContainer = headerDiv.querySelector('.category-actions'); // Find actions container

            controlsDiv.remove();
            labelSpan.classList.remove('hidden');
             if (actionsContainer) actionsContainer.classList.remove('hidden'); // Show actions again
        }

        // --- Rename Category Data Logic (REVISED) ---
        // Uses the full hierarchy path from the node's meta data.
        function renameCategoryInData(fullHierarchyPath, oldName, newName) {
             if (!fullHierarchyPath || fullHierarchyPath.length === 0 || !oldName || !newName || oldName === newName) {
                 console.warn("Rename aborted: Invalid parameters.");
                 return false;
             }

             let changesMade = false;
             const targetUrlType = fullHierarchyPath[0];
             // Determine the index within the item's *actual* hierarchy array that needs changing.
             // This depends on whether the format was skipped visually.
             // The last element in fullHierarchyPath IS the oldName we are looking for.
             const hierarchyRenameIndex = fullHierarchyPath.length - 2; // Index relative to start of item's hierarchy array


             classificationHistory.forEach(item => {
                 // Skip dummy items, they don't need renaming (and might lack full classification)
                 if (item.id.startsWith(DUMMY_ITEM_PREFIX)) return;

                 const classification = get(item, 'classification.classification');
                 if (!classification) return;

                 const itemUrlType = classification.url_type || 'Unknown Type';
                 const itemHierarchy = Array.isArray(classification.content_type_hierarchy)
                                       ? [...classification.content_type_hierarchy] // Copy
                                       : ['Unknown Category'];


                 // 1. Check if URL Type matches
                 if (itemUrlType === targetUrlType) {
                     // 2. Check if the item's hierarchy is long enough for the target level
                     if (itemHierarchy.length > hierarchyRenameIndex) {
                         // 3. Check if the segment *at the target level* matches the oldName
                         if (itemHierarchy[hierarchyRenameIndex] === oldName) {
                            // 4. Verify the prefix *before* the target level also matches the provided path
                            // (This ensures we're renaming the correct folder if names are duplicated at different levels)
                             let prefixMatch = true;
                             // Compare itemHierarchy[0...hierarchyRenameIndex-1] with fullHierarchyPath[1...hierarchyRenameIndex]
                             for (let i = 0; i < hierarchyRenameIndex; i++) {
                                 if (itemHierarchy[i] !== fullHierarchyPath[i + 1]) {
                                     prefixMatch = false;
                                     break;
                                 }
                             }

                             if (prefixMatch) {
                                 // All checks pass, rename the segment
                                 itemHierarchy[hierarchyRenameIndex] = newName;
                                 classification.content_type_hierarchy = itemHierarchy;
                                 changesMade = true;
                                 // console.log(`Updated item ${item.id}: hierarchy changed`);
                             }
                         }
                     }
                 }
             });

             if (changesMade) {
                 saveHistory();
             } else {
                  console.warn("Rename function executed, but no matching history entries found/modified for path:", fullHierarchyPath);
             }
             return changesMade;
        }


         // --- Drag and Drop Logic ---

         function moveHistoryEntry(entryId, targetUrlType, targetFormat, targetHierarchyArray) {
            // Ensure targetHierarchyArray is actually an array
            if (!Array.isArray(targetHierarchyArray)) {
                console.error("Cannot move entry: targetHierarchy is not an array.", targetHierarchyArray);
                return false;
            }

             const entryIndex = classificationHistory.findIndex(item => item.id === entryId);
             if (entryIndex === -1) {
                 console.error(`Cannot move entry: ID ${entryId} not found.`);
                 return false;
             }

             const entry = classificationHistory[entryIndex];
             const classification = get(entry, 'classification.classification');

             if (!classification) {
                 console.warn(`Creating classification structure for moved entry: ID ${entryId}.`);
                 // Ensure the structure exists if moving an item that somehow lacked it
                  if (!entry.classification) entry.classification = {};
                  if (!entry.classification.classification) entry.classification.classification = {};
                  classification = entry.classification.classification;
             }

             // Extract just the hierarchy *parts* from the target array (remove urlType/format if present)
             // The targetHierarchyArray from meta *includes* urlType and potentially format.
             let actualTargetHierarchy = [];
             const targetHierarchyStart = targetHierarchyArray.indexOf(targetUrlType) + 1; // Start after urlType
             if (targetHierarchyStart > 0 && targetHierarchyStart < targetHierarchyArray.length) {
                // Check if the next element is the format (and not the same as urlType)
                 const potentialFormat = targetHierarchyArray[targetHierarchyStart];
                 if (potentialFormat === targetFormat && targetFormat !== targetUrlType) {
                     actualTargetHierarchy = targetHierarchyArray.slice(targetHierarchyStart + 1);
                 } else {
                      actualTargetHierarchy = targetHierarchyArray.slice(targetHierarchyStart);
                 }
             }

             // Update the classification data
             classification.url_type = targetUrlType;
             classification.content_format = targetFormat;
             classification.content_type_hierarchy = actualTargetHierarchy; // Assign the extracted hierarchy parts

             console.log(`Moved entry ${entryId} to [${targetUrlType}/${targetFormat}]/[${actualTargetHierarchy.join('/')}]`);
             saveHistory();
             return true;
         }

         // --- Create Folder Logic ---
         function handleCreateFolder(createIcon) {
            const parentUrlType = createIcon.dataset.parentUrlType;
            const parentFormat = createIcon.dataset.parentFormat;
            const parentHierarchyString = createIcon.dataset.parentHierarchy;

            if (!parentUrlType || !parentFormat || !parentHierarchyString) {
                 console.error("Cannot create folder: Missing parent data on icon.");
                 return;
            }

             const newFolderName = prompt("Enter name for the new subfolder:");

             if (newFolderName && newFolderName.trim()) {
                 const trimmedName = newFolderName.trim();
                 try {
                     const parentHierarchy = JSON.parse(parentHierarchyString);

                     // Extract the actual hierarchy *parts* from the parent's full path meta
                     let parentHierarchyParts = [];
                     const parentHierarchyStart = parentHierarchy.indexOf(parentUrlType) + 1;
                     if (parentHierarchyStart > 0 && parentHierarchyStart < parentHierarchy.length) {
                         const potentialFormat = parentHierarchy[parentHierarchyStart];
                         if (potentialFormat === parentFormat && parentFormat !== parentUrlType) {
                             parentHierarchyParts = parentHierarchy.slice(parentHierarchyStart + 1);
                         } else {
                              parentHierarchyParts = parentHierarchy.slice(parentHierarchyStart);
                         }
                     } else if (parentHierarchyStart === parentHierarchy.length) {
                          // Parent was just the urlType node
                           parentHierarchyParts = [];
                     }


                     // Create the new hierarchy by appending the new name
                     const newHierarchy = [...parentHierarchyParts, trimmedName];

                     // Create dummy entry
                     const dummyEntry = {
                         id: generateId(true), // Mark as dummy
                         url: `${DUMMY_ITEM_PREFIX}${trimmedName}/${generateId()}`, // Unique placeholder URL
                         classification: {
                             classification: {
                                 url_type: parentUrlType,
                                 content_format: parentFormat,
                                 content_type_hierarchy: newHierarchy,
                                 primary_language: "Undetermined", // Default
                                 keywords: [],
                                 confidence: "Low"
                             }
                         }
                     };

                     console.log("Creating dummy entry:", dummyEntry);
                     classificationHistory.push(dummyEntry); // Add to history (push to end is fine)
                     saveHistory();

                     // Re-render the tree to show the new folder
                     const treeData = buildUrlTree(classificationHistory);
                     renderTree(treeData, urlTreeContainer);

                 } catch (e) {
                     console.error("Error parsing parent hierarchy or creating folder:", e);
                     alert("Failed to create folder due to an internal error.");
                 }
             } else if (newFolderName !== null) { // User entered empty string or only whitespace
                  alert("Folder name cannot be empty.");
             }
             // If prompt returns null (Cancel), do nothing.
         }


        // --- Tab Switching Logic ---
        function switchTab(event) { /* ... no changes ... */
             if (draggedElement) {
                 draggedElement.classList.remove('dragging');
                 draggedElement = null;
            }
            document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));

            const targetId = event.currentTarget.dataset.target;
            tabButtons.forEach(button => {
                button.classList.toggle('active', button.dataset.target === targetId);
            });
            pageContents.forEach(page => {
                page.classList.toggle('active', page.id === targetId);
            });
             if (targetId === 'treePage') {
                 const treeData = buildUrlTree(classificationHistory);
                 renderTree(treeData, urlTreeContainer);
             }
        }

        // --- Main Classification Function ---
        async function classifyUrlContent() { /* ... no changes ... */
            const pageUrl = urlInput.value.trim();
            if (!pageUrl || !/^https?:\/\/.+/.test(pageUrl)) {
                displayResultInArea(classifierResultDisplay, "Please enter a valid URL (starting with http:// or https://).", true);
                return;
            }
            showLoading(true);
            try {
                const response = await fetch(NETLIFY_FUNCTION_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url: pageUrl })
                });
                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error || `Function Error: ${response.status} ${response.statusText}`);
                }

                if (data.classification && typeof data.classification === 'object' && data.classification.classification) {
                    displayResultInArea(classifierResultDisplay, data.classification, false, 'API Result');
                    addHistoryEntry(pageUrl, data.classification);
                } else {
                     console.warn("Received unexpected response format:", data);
                     throw new Error("Received an unexpected response format from the classification service.");
                }
            } catch (error) {
                console.error("Error during classification:", error);
                displayResultInArea(classifierResultDisplay, `Classification failed: ${error.message}`, true);
            } finally {
                showLoading(false);
            }
        }

        // --- Initialization and Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            loadHistory();

            // Tab switching
            tabButtons.forEach(button => button.addEventListener('click', switchTab));

            // Classifier action
            classifyButton.addEventListener('click', classifyUrlContent);
            urlInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') { event.preventDefault(); classifyUrlContent(); }
            });

            // History actions
            clearHistoryButton.addEventListener('click', clearHistory);
            showAllButton.addEventListener('click', showAllHistory);

            // --- Event delegation for tree actions ---
            urlTreeContainer.addEventListener('click', (event) => {
                 // Handle Rename Icon Clicks
                 const renameIcon = event.target.closest('.rename-icon');
                 if (renameIcon) {
                      event.stopPropagation();
                      showRenameInput(renameIcon);
                      return; // Processed
                 }
                 // Handle Create Folder Icon Clicks
                  const createFolderIcon = event.target.closest('.create-folder-icon');
                  if (createFolderIcon) {
                      event.stopPropagation();
                      handleCreateFolder(createFolderIcon);
                      return; // Processed
                  }

                 // Note: Delete handled directly on button, Toggle handled directly on icon
            });

            // --- Drag and Drop Event Listeners (Delegated) ---
            urlTreeContainer.addEventListener('dragstart', (event) => { /* ... no changes ... */
                const targetLi = event.target.closest('li.url-link');
                if (targetLi && targetLi.draggable) {
                    draggedElement = targetLi;
                    const entryId = targetLi.dataset.entryId;
                    event.dataTransfer.setData(DRAG_DATA_TYPE, entryId);
                    event.dataTransfer.effectAllowed = 'move';
                    setTimeout(() => { targetLi.classList.add('dragging'); }, 0);
                    // console.log(`Drag Start: Entry ID ${entryId}`);
                }
            });

            urlTreeContainer.addEventListener('dragend', (event) => { /* ... no changes ... */
                 if (draggedElement) {
                     draggedElement.classList.remove('dragging');
                     draggedElement = null;
                     document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
                     // console.log("Drag End");
                 }
            });

            urlTreeContainer.addEventListener('dragover', (event) => { /* ... no changes ... */
                 const dropTarget = event.target.closest('.category-label');
                if (dropTarget && draggedElement) {
                    event.preventDefault();
                    event.dataTransfer.dropEffect = 'move';
                    dropTarget.classList.add('drag-over');
                }
            });

             urlTreeContainer.addEventListener('dragleave', (event) => { /* ... no changes ... */
                 const dropTarget = event.target.closest('.category-label');
                 if (dropTarget) {
                    dropTarget.classList.remove('drag-over');
                 }
            });

             urlTreeContainer.addEventListener('drop', (event) => { /* ... uses hierarchy array now ... */
                event.preventDefault();
                const dropTarget = event.target.closest('.category-label');
                 if (dropTarget && draggedElement) {
                     dropTarget.classList.remove('drag-over');

                     const entryId = event.dataTransfer.getData(DRAG_DATA_TYPE);
                     const targetUrlType = dropTarget.dataset.targetUrlType;
                     const targetFormat = dropTarget.dataset.targetFormat;
                     const targetHierarchyString = dropTarget.dataset.targetHierarchy; // Get the full path string

                     console.log(`Drop: Entry ID ${entryId} onto Category Meta [${targetHierarchyString}]`);

                     if (entryId && targetUrlType && targetFormat && targetHierarchyString) {
                          try {
                              const targetHierarchyArray = JSON.parse(targetHierarchyString); // Parse the full path

                              if (moveHistoryEntry(entryId, targetUrlType, targetFormat, targetHierarchyArray)) { // Pass the full array
                                  const treeData = buildUrlTree(classificationHistory);
                                  renderTree(treeData, urlTreeContainer);
                              } else {
                                  console.error("Failed to move history entry in data.");
                              }
                          } catch (e) {
                               console.error("Drop failed: Error parsing target hierarchy.", e);
                          }
                     } else {
                         console.error("Drop failed: Missing data from dragged item or drop target.", { entryId, targetUrlType, targetFormat, targetHierarchyString });
                     }
                 }
                 if (draggedElement) {
                     draggedElement.classList.remove('dragging');
                     draggedElement = null;
                 }
             });


            // Ensure default tab content is shown
            document.querySelector('.page-content.active') || document.getElementById('classifierPage').classList.add('active');
            document.querySelector('.tab-button.active') || document.querySelector('.tab-button[data-target="classifierPage"]').classList.add('active');
        });

    </script>
</body>
</html>