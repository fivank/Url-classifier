<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Page Classifier & History</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* --- Base Styles --- */
        :root {
            --primary: #2563eb;
            --primary-dark: #1d4ed8;
            --primary-light: #dbeafe;
            --success: #10b981;
            --success-dark: #047857;
            --success-light: #d1fae5;
            --danger: #ef4444;
            --danger-dark: #b91c1c;
            --danger-light: #fee2e2;
            --neutral-50: #f9fafb;
            --neutral-100: #f3f4f6;
            --neutral-200: #e5e7eb;
            --neutral-300: #d1d5db;
            --neutral-400: #9ca3af;
            --neutral-500: #6b7280;
            --neutral-600: #4b5563;
            --neutral-700: #374151;
            --neutral-800: #1f2937;
            --neutral-900: #111827;
            --info-light: #dbeafe;
            --info-dark: #1e3a8a;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.1);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1);
            --radius-sm: 0.25rem;
            --radius: 0.5rem;
            --radius-md: 0.75rem;
            --radius-lg: 1rem;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            background-color: var(--neutral-100);
            color: var(--neutral-800);
            padding: 20px;
            font-size: 16px;
        }

        .main-wrapper {
            background-color: #ffffff;
            padding: 0;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
            width: 100%;
            max-width: 900px;
            margin: 0 auto;
            overflow: hidden;
            position: relative;
            transition: box-shadow 0.3s ease;
        }

        .main-wrapper:hover {
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }

        /* --- Header --- */
        h1 {
            text-align: center;
            font-size: 1.8em;
            padding: 1.5rem 0;
            color: var(--primary);
            font-weight: 700;
            margin-bottom: 0;
            background-color: white;
            border-bottom: 1px solid var(--neutral-200);
        }

        h2 {
            font-size: 1.3em;
            margin-bottom: 1rem;
            text-align: left;
            color: var(--neutral-800);
            font-weight: 600;
        }

        /* --- Tab Navigation --- */
        .tab-container {
            display: flex;
            background-color: white;
            border-bottom: 1px solid var(--neutral-200);
            padding: 0 1rem;
        }

        .tab-button {
            padding: 1rem 1.25rem;
            cursor: pointer;
            border: none;
            background-color: transparent;
            font-size: 1rem;
            font-weight: 500;
            color: var(--neutral-600);
            transition: all 0.2s ease;
            border-bottom: 3px solid transparent;
            position: relative;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tab-button:hover {
            color: var(--primary);
            background-color: var(--neutral-50);
        }

        .tab-button.active {
            color: var(--primary);
            border-bottom: 3px solid var(--primary);
        }

        .tab-button.active::after {
            content: "";
            position: absolute;
            bottom: -3px;
            left: 0;
            right: 0;
            height: 3px;
            background-color: var(--primary);
            border-radius: 3px 3px 0 0;
        }

        .tab-button i {
            font-size: 0.9rem;
        }

        /* --- Page Content --- */
        .page-content {
            display: none;
            padding: 2rem;
            animation: fadeIn 0.3s ease;
        }

        .page-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* --- Form Elements --- */
        .form-group {
            margin-bottom: 1.5rem;
            text-align: left;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--neutral-700);
            font-size: 0.95rem;
        }

        input[type="url"], input[type="text"].rename-input {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 1px solid var(--neutral-300);
            border-radius: var(--radius);
            font-size: 1rem;
            font-family: inherit;
            transition: all 0.2s ease;
            background-color: white;
        }

        input[type="url"]:focus, input[type="text"].rename-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.15);
        }

        input[type="url"]::placeholder {
            color: var(--neutral-400);
        }

        button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 0.75rem 1.25rem;
            border-radius: var(--radius);
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        button:hover {
            background-color: var(--primary-dark);
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background-color: var(--neutral-400);
            cursor: not-allowed;
            transform: none;
        }

        button#classifyButton {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 150px;
            width: 100%;
        }

        /* Style for delete/action buttons in history and tree */
        .action-button {
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 0.1rem 0.3rem; /* Smaller padding */
            font-size: 0.85em; /* Slightly smaller icon */
            line-height: 1;
            margin-left: 0.3rem;
            vertical-align: middle;
        }
        .action-button.delete-button { color: var(--danger); }
        .action-button.delete-button:hover { color: var(--danger-dark); }
        .action-button.rename-icon { color: var(--neutral-500); }
        .action-button.rename-icon:hover { color: var(--primary); }
        .action-button.save-rename { color: var(--success); }
        .action-button.save-rename:hover { color: var(--success-dark); }
        .action-button.cancel-rename { color: var(--neutral-600); }
        .action-button.cancel-rename:hover { color: var(--neutral-800); }

        /* Container for inline rename controls */
        .rename-controls {
            display: inline-flex; /* Changed from flex to inline-flex */
            align-items: center;
            gap: 0.5rem;
            width: calc(100% - 30px); /* Adjust width as needed */
            margin-left: 0.5rem; /* Add some space */
        }
        .rename-controls input.rename-input {
            flex-grow: 1;
            font-size: 0.9em; /* Match surrounding text */
            padding: 0.3rem 0.5rem; /* Smaller padding */
            /* Remove width: 100% */
        }
        .rename-controls .action-button {
             margin-left: 0.1rem; /* Reduce margin */
        }


        /* --- Loader --- */
        .loader {
            border: 3px solid rgba(255,255,255,0.3);
            border-top: 3px solid white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            animation: spin 1s linear infinite;
            display: none;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* --- Info Boxes --- */
        .info {
            background-color: var(--info-light);
            color: var(--info-dark);
            border-left: 4px solid var(--primary);
            padding: 1rem;
            border-radius: var(--radius-sm);
            margin-bottom: 1.5rem;
            text-align: left;
            font-size: 0.95rem;
        }

        /* --- Result Display --- */
        .result-display-area {
            margin-top: 1.5rem;
            padding: 1.5rem;
            background-color: white;
            border-radius: var(--radius);
            border: 1px solid var(--neutral-200);
            text-align: left;
            word-wrap: break-word;
            display: none;
            font-size: 0.95em;
            min-height: 100px;
            box-shadow: var(--shadow-sm);
            transition: all 0.3s ease;
        }

        .result-display-area.error {
            background-color: var(--danger-light);
            color: var(--danger);
            border-left: 4px solid var(--danger);
        }

        .result-display-area strong.title {
            display: block;
            margin-bottom: 0.75rem;
            color: var(--primary);
            font-weight: 600;
            font-size: 1.1rem;
            border-bottom: 1px solid var(--neutral-200);
            padding-bottom: 0.75rem;
        }

        .result-display-area.error strong.title {
            color: var(--danger);
        }

        .result-display-area pre {
            background-color: var(--neutral-50);
            padding: 1rem;
            border-radius: var(--radius-sm);
            border: 1px solid var(--neutral-200);
            font-family: Monaco, Menlo, Consolas, "Liberation Mono", monospace;
            white-space: pre-wrap;
            word-break: break-all;
            font-size: 0.9rem;
            margin: 0;
            color: var(--neutral-800);
            overflow-x: auto;
            max-height: 400px;
            overflow-y: auto;
        }

        .result-display-area.error pre {
            color: var(--danger);
            background-color: transparent;
            border: none;
            padding: 0;
            white-space: pre-wrap;
            font-family: inherit;
            font-size: 1em;
        }

        /* --- History List --- */
        #historyList {
            list-style: none;
            padding: 0;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--neutral-200);
            border-radius: var(--radius);
            margin-bottom: 1rem;
            background-color: white;
        }

        #historyList li {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--neutral-200);
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            transition: background-color 0.2s ease;
            color: var(--neutral-700);
        }

        #historyList li:last-child {
            border-bottom: none;
        }

        #historyList li:hover {
            background-color: var(--neutral-100);
        }

        #historyList li.selected {
            background-color: var(--primary-light);
            color: var(--primary-dark);
            font-weight: 500;
            border-left: 4px solid var(--primary);
        }

        /* Ensure delete button aligns correctly in list */
        #historyList .action-button.delete-button {
            margin-left: auto; /* Push delete button to the right */
            padding-left: 0.5rem; /* Add some space */
        }

        /* --- History Actions --- */
        .history-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            gap: 0.75rem;
        }

        .history-actions button {
            margin-top: 0;
            padding: 0.75rem 1rem;
            font-size: 0.9rem;
            flex-shrink: 0;
        }

        #showAllButton {
            background-color: var(--success);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        #showAllButton:hover {
            background-color: #0d9488;
        }

        #clearHistoryButton {
            background-color: var(--danger);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        #clearHistoryButton:hover {
            background-color: #b91c1c;
        }

        /* --- URL Tree --- */
        #urlTreeContainer {
            font-size: 0.95rem;
            border: 1px solid var(--neutral-200);
            padding: 1.5rem;
            border-radius: var(--radius);
            max-height: 500px;
            overflow: auto;
            background-color: white;
            box-shadow: var(--shadow-sm);
        }

        #urlTreeContainer ul {
            list-style: none;
            padding-left: 1.5rem;
            margin-top: 0.5rem;
        }

        #urlTreeContainer li {
            margin-bottom: 0.5rem;
            position: relative;
        }

        /* Folder toggle icon */
        .toggle-icon {
            cursor: pointer;
            margin-right: 0.5rem;
            width: 1em; /* Ensure consistent width */
            display: inline-block;
            text-align: center;
        }

        #urlTreeContainer li::before {
            content: "";
            position: absolute;
            left: -1rem;
            top: 0.7rem; /* Adjust if needed */
            width: 0.5rem;
            height: 0;
            border-top: 1px solid var(--neutral-300);
        }

        #urlTreeContainer ul > li::after {
            content: "";
            position: absolute;
            left: -1rem;
            top: 0;
            height: 100%;
            border-left: 1px solid var(--neutral-300);
        }

        #urlTreeContainer ul > li:last-child::after {
            height: 0.7rem; /* Adjust vertical line height for last item */
        }

        /* Style for category labels (potential drop targets) */
        #urlTreeContainer .category-label {
            font-weight: 600;
            color: var(--neutral-700);
            display: inline-flex; /* Use inline-flex to allow items side-by-side */
            align-items: center;
            margin-bottom: 0.3rem;
            padding: 0.25rem 0.5rem; /* Add some padding for easier dropping */
            position: relative; /* Needed for positioning rename controls */
            width: 100%; /* Take full width to contain inline elements */
            border-radius: var(--radius-sm); /* Add radius */
            transition: background-color 0.2s ease, border 0.2s ease; /* Transition for drag-over */
            border: 1px solid transparent; /* Placeholder for dashed border */
        }
        #urlTreeContainer .category-label > .label-text {
             margin-right: 5px; /* Space between text and rename icon */
             pointer-events: none; /* Prevent text from interfering with drop */
        }
        /* Style for drop zone indication */
        #urlTreeContainer .category-label.drag-over {
            background-color: var(--primary-light);
            border: 1px dashed var(--primary);
        }


        /* Add folder icon using FA class */
        #urlTreeContainer .category-label .folder-icon {
            margin-right: 0.5rem;
            color: var(--primary);
             pointer-events: none; /* Prevent icon interfering */
        }

        /* Style for URL links (draggable items) */
        #urlTreeContainer .url-link {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.25rem 0.5rem; /* Add padding */
            border-radius: var(--radius-sm);
            transition: opacity 0.2s ease; /* Transition for dragging */
            cursor: grab; /* Indicate draggable */
        }
        /* Style for when dragging */
         #urlTreeContainer .url-link.dragging {
            opacity: 0.5;
            cursor: grabbing;
            background-color: var(--neutral-200);
        }


        #urlTreeContainer .url-link a {
            color: var(--primary);
            text-decoration: none;
            word-break: break-all;
            font-size: 0.9rem;
            display: inline-flex;
            align-items: center;
            margin-right: 5px; /* Space before delete button */
            pointer-events: none; /* Allow dragging the LI element */
        }

        #urlTreeContainer .url-link a::before {
            content: "\f0c1"; /* link icon */
            font-family: "Font Awesome 6 Free";
            font-weight: 900;
            margin-right: 0.5rem;
            font-size: 0.8rem;
            color: var(--neutral-500);
        }

        #urlTreeContainer .url-link a:hover {
            /* text-decoration: underline; */ /* Remove underline to avoid confusion with drag */
        }

        #urlTreeContainer .empty-tree {
            font-style: italic;
            color: var(--neutral-500);
            text-align: center;
            padding: 2rem;
        }

        /* Hidden utility class */
        .hidden {
            display: none !important;
        }

        /* --- Responsive Styles --- */
        @media (max-width: 768px) {
            .main-wrapper {
                border-radius: var(--radius);
            }

            .page-content {
                padding: 1.25rem;
            }
            #urlTreeContainer .category-label,
            #urlTreeContainer .url-link a {
                 max-width: calc(100% - 40px); /* Prevent overlap with buttons */
            }
        }

        @media (max-width: 600px) {
            body {
                padding: 10px;
            }

            h1 {
                font-size: 1.5rem;
                padding: 1rem 0;
            }

            .tab-button {
                padding: 0.75rem 0.5rem;
                font-size: 0.85rem;
            }

            .tab-container {
                padding: 0;
            }

            .tab-button i {
                margin-right: 0;
            }

            .tab-button span {
                display: none;
            }

            .history-actions {
                flex-direction: column;
            }

            .history-actions button {
                width: 100%;
            }

            #urlTreeContainer ul {
                padding-left: 1rem;
            }

            .result-display-area pre {
                font-size: 0.8rem;
            }
             /* Adjust rename controls for small screens */
            .rename-controls {
                width: calc(100% - 20px); /* Ensure it fits */
            }
             #urlTreeContainer .category-label,
             #urlTreeContainer .url-link a {
                  max-width: calc(100% - 50px); /* More aggressive on small screens */
             }
        }
    </style>
</head>
<body>
    <div class="main-wrapper">
        <h1>Web Page Classifier</h1>

        <!-- Tab Navigation -->
        <div class="tab-container">
            <button class="tab-button active" data-target="classifierPage">
                <i class="fas fa-magnifying-glass"></i>
                <span>Classifier</span>
            </button>
            <button class="tab-button" data-target="historyPage">
                <i class="fas fa-clock-rotate-left"></i>
                <span>History</span>
            </button>
            <button class="tab-button" data-target="treePage">
                <i class="fas fa-sitemap"></i>
                <span>URL Tree</span>
            </button>
        </div>

        <!-- Classifier Page Content -->
        <div id="classifierPage" class="page-content active">
            <div class="info">
                <i class="fas fa-circle-info"></i> Enter a URL. The classification result (JSON) will be displayed below and saved to history.
            </div>
            <div class="form-group">
                <label for="pageUrl">Web Page URL:</label>
                <input type="url" id="pageUrl" placeholder="https://example.com/article" required>
            </div>
            <button id="classifyButton">
                <div class="loader" id="loader"></div>
                <span>Classify URL</span>
            </button>
            <div id="classifierResultDisplay" class="result-display-area">
                <strong class="title">Result:</strong>
                <pre></pre>
            </div>
        </div>

        <!-- History Page Content -->
        <div id="historyPage" class="page-content">
            <h2>Classification History List</h2>
            <ul id="historyList"><li></li></ul> <!-- Initial empty li placeholder handled by JS -->
            <div class="history-actions">
                <button id="showAllButton">
                    <i class="fas fa-list"></i>
                    <span>Show All URLs & Classifications</span>
                </button>
                <button id="clearHistoryButton">
                    <i class="fas fa-trash-can"></i>
                    <span>Clear History</span>
                </button>
            </div>
            <div id="historyResultDisplay" class="result-display-area">
                <strong class="title">Selected / All History:</strong>
                <pre></pre>
            </div>
        </div>

        <!-- Tree Page Content -->
        <div id="treePage" class="page-content">
            <h2>URL Classification Tree</h2>
            <div class="info">
                <i class="fas fa-circle-info"></i> URLs are categorized. Drag & drop a URL (<i class="fas fa-link"></i>) onto a category (<i class="fas fa-folder"></i>) to reclassify. Click <i class="fas fa-chevron-down"></i>/<i class="fas fa-chevron-right"></i> to fold/unfold. Click <i class="fas fa-pencil-alt"></i> to rename a category. Click <i class="fas fa-trash-alt"></i> to remove a URL entry.
            </div>
            <div id="urlTreeContainer">
                <!-- Tree will be rendered here by JavaScript -->
            </div>
        </div>

    </div> <!-- End main-wrapper -->

    <script>
        // --- Configuration ---
        const NETLIFY_FUNCTION_ENDPOINT = '/.netlify/functions/classify-url';
        const LOCAL_STORAGE_KEY = 'urlClassificationHistory';
        const DRAG_DATA_TYPE = 'text/plain'; // Data type for drag/drop ID

        // --- DOM Elements ---
        const classifyButton = document.getElementById('classifyButton');
        const urlInput = document.getElementById('pageUrl');
        const loader = document.getElementById('loader');
        const buttonText = classifyButton.querySelector('span');
        const classifierResultDisplay = document.getElementById('classifierResultDisplay');
        const historyResultDisplay = document.getElementById('historyResultDisplay');
        const historyList = document.getElementById('historyList');
        const clearHistoryButton = document.getElementById('clearHistoryButton');
        const showAllButton = document.getElementById('showAllButton');
        const urlTreeContainer = document.getElementById('urlTreeContainer');
        const tabButtons = document.querySelectorAll('.tab-button');
        const pageContents = document.querySelectorAll('.page-content');

        // --- State ---
        let classificationHistory = []; // In-memory copy
        let draggedElement = null; // Keep track of the element being dragged

        // --- Helper: Generate Unique ID ---
        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substring(2);
        }

        // --- Functions ---

        function showLoading(isLoading) {
            if (isLoading) {
                classifyButton.disabled = true;
                loader.style.display = 'inline-block';
                buttonText.textContent = 'Classifying...';
                classifierResultDisplay.style.display = 'none';
                classifierResultDisplay.classList.remove('error');
            } else {
                classifyButton.disabled = false;
                loader.style.display = 'none';
                buttonText.textContent = 'Classify URL';
            }
        }

        function displayResultInArea(areaElement, data, isError = false, titlePrefix = 'Result') {
            areaElement.innerHTML = ''; // Clear previous content
            areaElement.style.display = 'block';
            const title = document.createElement('strong');
            title.classList.add('title');
            const resultOutput = document.createElement('pre');
            if (isError) {
                areaElement.classList.add('error');
                title.textContent = `Error:`;
                resultOutput.textContent = (typeof data === 'string') ? data : JSON.stringify(data, null, 2);
            } else {
                areaElement.classList.remove('error');
                title.textContent = `${titlePrefix}:`;
                resultOutput.textContent = JSON.stringify(data, null, 2);
            }
            areaElement.appendChild(title);
            areaElement.appendChild(resultOutput);
        }

        // Delete an entry from history by id
        function deleteHistoryEntryById(entryId) {
            const initialLength = classificationHistory.length;
            classificationHistory = classificationHistory.filter(entry => entry.id !== entryId);
            if (classificationHistory.length < initialLength) {
                saveHistory();
                renderHistoryList();
                // Rebuild tree to reflect deletion
                const treeData = buildUrlTree(classificationHistory);
                renderTree(treeData, urlTreeContainer);
                 // Hide history display if the deleted item was selected
                 historyResultDisplay.style.display = 'none';
                 document.querySelectorAll('#historyList li.selected').forEach(el => el.classList.remove('selected'));
                 console.log(`Deleted history entry ${entryId}`);
            } else {
                console.warn(`Attempted to delete non-existent entry ${entryId}`);
            }
        }

        // --- History List Rendering and Management ---

        function renderHistoryList() {
            historyList.innerHTML = ''; // Clear previous list
            if (classificationHistory.length === 0) {
                const emptyLi = document.createElement('li');
                emptyLi.textContent = "No history yet.";
                emptyLi.style.fontStyle = "italic";
                emptyLi.style.color = "var(--neutral-500)";
                emptyLi.style.textAlign = "center";
                emptyLi.style.cursor = "default";
                historyList.appendChild(emptyLi);
                return;
            }

            classificationHistory.forEach((item) => {
                const li = document.createElement('li');
                const textSpan = document.createElement('span'); // Span for text content
                textSpan.textContent = item.url;
                textSpan.style.overflow = 'hidden';
                textSpan.style.textOverflow = 'ellipsis';
                textSpan.style.whiteSpace = 'nowrap';
                textSpan.title = item.url; // Tooltip for full URL
                li.appendChild(textSpan);

                li.dataset.id = item.id;

                // Delete button for history entry
                const delBtn = document.createElement('button');
                delBtn.classList.add('action-button', 'delete-button');
                delBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
                delBtn.title = "Delete this entry"; // Tooltip
                delBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent li click event
                    deleteHistoryEntryById(item.id);
                });

                li.appendChild(delBtn); // Append delete button

                li.addEventListener('click', () => {
                    document.querySelectorAll('#historyList li.selected').forEach(el => el.classList.remove('selected'));
                    li.classList.add('selected');
                    if (item.classification) {
                        displayResultInArea(historyResultDisplay, item.classification, false, `Selected: ${item.url}`);
                    } else {
                        displayResultInArea(historyResultDisplay, "Classification data missing for this entry.", true, `Selected: ${item.url}`);
                    }
                });
                historyList.appendChild(li);
            });
        }

        function loadHistory() {
            try {
                const storedHistory = localStorage.getItem(LOCAL_STORAGE_KEY);
                classificationHistory = storedHistory ? JSON.parse(storedHistory) : [];
                 if (!Array.isArray(classificationHistory)) {
                     console.warn("Stored history was not an array, resetting.");
                     classificationHistory = [];
                     localStorage.removeItem(LOCAL_STORAGE_KEY);
                 }
            } catch (error) {
                console.error("Error loading/parsing history:", error);
                classificationHistory = [];
            }
            renderHistoryList();
            const treeData = buildUrlTree(classificationHistory);
            renderTree(treeData, urlTreeContainer);
        }

        function saveHistory() {
            try {
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(classificationHistory));
            } catch (error) {
                console.error("Error saving history:", error);
                displayResultInArea(classifierResultDisplay, "Could not save history (Storage might be full).", true);
            }
        }

        function addHistoryEntry(url, classificationData) {
            const newEntry = { id: generateId(), url: url, classification: classificationData };
            classificationHistory.unshift(newEntry);
            saveHistory();
            renderHistoryList();
            const treeData = buildUrlTree(classificationHistory);
            renderTree(treeData, urlTreeContainer);
        }

        function showAllHistory() {
            if (classificationHistory.length === 0) {
                displayResultInArea(historyResultDisplay, "History is empty.", true, "Full History");
            } else {
                 const displayHistory = classificationHistory.map(({ id, ...rest }) => rest);
                 displayResultInArea(historyResultDisplay, displayHistory, false, "All Stored Classifications");
            }
            document.querySelectorAll('#historyList li.selected').forEach(el => el.classList.remove('selected'));
        }

        function clearHistory() {
            if (confirm("Are you sure you want to clear the entire classification history? This cannot be undone.")) {
                classificationHistory = [];
                saveHistory();
                renderHistoryList();
                historyResultDisplay.style.display = 'none';
                urlTreeContainer.innerHTML = '<div class="empty-tree">History cleared.</div>';
            }
        }


        // --- Tree Building and Rendering Logic ---

        // Helper to safely get nested properties
        const get = (obj, path, defaultValue = undefined) => {
          const travel = (regexp) =>
            String.prototype.split
              .call(path, regexp)
              .filter(Boolean)
              .reduce((res, key) => (res !== null && res !== undefined ? res[key] : res), obj);
          const result = travel(/[,[\]]+?/) || travel(/[,[\].]+?/);
          return result === undefined || result === obj ? defaultValue : result;
        };


        function buildUrlTree(history) {
            const tree = {}; // Root of the tree

            history.forEach(item => {
                const classification = get(item, 'classification.classification');
                if (!classification) return;

                const urlType = classification.url_type || 'Unknown Type';
                const format = classification.content_format || 'Unknown Format';
                const hierarchy = Array.isArray(classification.content_type_hierarchy) && classification.content_type_hierarchy.length > 0
                                  ? classification.content_type_hierarchy
                                  : ['Unknown Category'];

                let currentLevel = tree;

                // Level 1: URL Type
                if (!currentLevel[urlType]) currentLevel[urlType] = { _meta: { urlType: urlType, format: null, hierarchy: [] } }; // Add meta for root type
                currentLevel = currentLevel[urlType];


                // Level 2: Content Format (Conditional based on 'HTML')
                 let formatKey = format;
                 let actualFormatForMeta = format; // Format to store in meta
                 if (format.trim().toLowerCase() !== 'html') {
                     if (!currentLevel[formatKey]) currentLevel[formatKey] = { _meta: { urlType: urlType, format: actualFormatForMeta, hierarchy: [] } }; // Meta includes format
                     currentLevel = currentLevel[formatKey];
                 } else {
                    // If format is HTML, we skip adding a node, but the *parent's* meta needs to know
                    // The meta added at urlType level already correctly has format: null (or its actual format if !== HTML)
                    // We will use 'HTML' as the format value when updating based on dropping onto a urlType node directly
                    actualFormatForMeta = 'HTML'; // Use 'HTML' when target is urlType level
                 }


                // Levels 3+: Content Type Hierarchy
                hierarchy.forEach((category, index) => {
                    const isLastLevel = index === hierarchy.length - 1;
                    const currentHierarchyPath = hierarchy.slice(0, index + 1);

                    if (!currentLevel[category]) {
                         const meta = {
                             urlType: urlType,
                             format: actualFormatForMeta, // Use the determined format
                             hierarchy: currentHierarchyPath
                         };
                         currentLevel[category] = isLastLevel ? { _meta: meta, _items: [] } : { _meta: meta };
                    } else if (isLastLevel && !currentLevel[category]._items) {
                         // Ensure _items array exists if we're adding to an existing folder node
                          currentLevel[category]._items = [];
                          // Ensure meta exists if node was created without it somehow
                          if (!currentLevel[category]._meta) {
                               currentLevel[category]._meta = {
                                    urlType: urlType,
                                    format: actualFormatForMeta,
                                    hierarchy: currentHierarchyPath
                               };
                          }
                    }

                    // Add item or move to next level
                     if (isLastLevel) {
                        // Add the URL entry object if not already present in _items array
                        if (!currentLevel[category]._items.some(entry => entry.id === item.id)) {
                            currentLevel[category]._items.push({ id: item.id, url: item.url });
                        }
                    }
                    // Move down only if not the last level
                    if (!isLastLevel) {
                       currentLevel = currentLevel[category];
                    }
                });
            });
            // console.log("Built Tree:", JSON.stringify(tree, null, 2));
            return tree;
        }


        function renderTree(treeData, containerElement) {
            containerElement.innerHTML = ''; // Clear previous tree
            if (Object.keys(treeData).length === 0) {
                containerElement.innerHTML = '<div class="empty-tree">No classification data available to build the tree.</div>';
                return;
            }
            const rootUl = document.createElement('ul');
            containerElement.appendChild(rootUl);
            renderTreeNode(treeData, rootUl); // Removed path tracking, using meta now
        }

        // Modified renderTreeNode - simplified path tracking, uses _meta and _items
        function renderTreeNode(node, parentUl) {
             // Get category keys, excluding internal _meta and _items
            const categories = Object.keys(node).filter(key => key !== '_meta' && key !== '_items').sort();

            categories.forEach(category => {
                const li = document.createElement('li');
                const nodeValue = node[category]; // This is the child object (folder)
                const meta = nodeValue._meta; // Meta of the child node
                const items = nodeValue._items; // Array of items directly under this category, if any

                const isFolder = typeof nodeValue === 'object' && Object.keys(nodeValue).some(k => k !== '_meta' && k !== '_items'); // Has child categories?
                const isLeafListContainer = Array.isArray(items) && items.length > 0; // Contains URL items?

                 if (!meta) {
                    console.warn("Node missing _meta data:", category, nodeValue);
                    return; // Skip rendering this node if meta is missing
                 }

                // --- Create Header (Drop Target) ---
                const header = document.createElement('div');
                header.classList.add('category-label'); // Potential drop target

                // Store target data directly on the header element
                header.dataset.targetUrlType = meta.urlType;
                // Store the format correctly - use 'HTML' if meta format is null (meaning HTML was skipped)
                header.dataset.targetFormat = meta.format === null ? 'HTML' : meta.format;
                header.dataset.targetHierarchy = JSON.stringify(meta.hierarchy); // Full hierarchy path to this node

                // Toggle Icon
                const toggleIcon = document.createElement('i');
                 // Show toggle if it's a folder OR it directly contains items
                if (isFolder || isLeafListContainer) {
                   toggleIcon.classList.add('toggle-icon', 'fas', 'fa-chevron-down');
                } else {
                   toggleIcon.classList.add('toggle-icon', 'fas', 'fa-minus'); // Placeholder if no children/items
                   toggleIcon.style.opacity = '0.3';
                   toggleIcon.style.cursor = 'default';
                }

                // Folder Icon & Label Text Span
                const iconSpan = document.createElement('i');
                iconSpan.classList.add('fas', 'fa-folder', 'folder-icon');
                const labelSpan = document.createElement('span');
                labelSpan.classList.add('label-text');
                labelSpan.textContent = category;

                header.appendChild(toggleIcon);
                header.appendChild(iconSpan);
                header.appendChild(labelSpan);

                // Rename Icon
                const renameIcon = document.createElement('button');
                renameIcon.classList.add('action-button', 'rename-icon');
                renameIcon.innerHTML = '<i class="fas fa-pencil-alt"></i>';
                renameIcon.title = `Rename category "${category}"`;
                renameIcon.dataset.categoryName = category;
                // We still need the *visual* path for renaming logic if it differs from meta hierarchy
                 // Let's reconstruct the visual path for rename - find parent meta
                 // This is getting complex. Stick to renaming based on meta.hierarchy for now.
                 // Rename logic might need adjustment if visual path skips HTML format.
                 renameIcon.dataset.fullPath = JSON.stringify(meta.hierarchy); // Use meta hierarchy for rename path
                header.appendChild(renameIcon);


                li.appendChild(header);

                // --- Create Nested List (ul) for Children ---
                let nestedUl = null;
                if (isFolder || isLeafListContainer) {
                    nestedUl = document.createElement('ul');

                    // Render child categories (folders)
                    if (isFolder) {
                        renderTreeNode(nodeValue, nestedUl); // Pass the child node itself
                    }

                    // Render items (URLs) directly under this category
                    if (isLeafListContainer) {
                        items.sort((a, b) => a.url.localeCompare(b.url)).forEach(entry => {
                            const urlLi = document.createElement('li');
                            urlLi.classList.add('url-link');
                            urlLi.draggable = true; // Make URL item draggable
                            urlLi.dataset.entryId = entry.id; // Store ID for drag/drop & delete

                            const link = document.createElement('a');
                            link.href = entry.url;
                            link.textContent = entry.url;
                            link.title = entry.url;
                            link.target = '_blank';
                            link.rel = 'noopener noreferrer';
                            urlLi.appendChild(link);

                            const deleteBtn = document.createElement('button');
                            deleteBtn.classList.add('action-button', 'delete-button');
                            deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
                            deleteBtn.title = "Delete this URL entry";
                             // deleteBtn.dataset.entryId = entry.id; // ID is on parent LI now
                            deleteBtn.addEventListener('click', (e) => {
                                e.stopPropagation();
                                deleteHistoryEntryById(entry.id);
                            });
                            urlLi.appendChild(deleteBtn);
                            nestedUl.appendChild(urlLi);
                        });
                    }
                     li.appendChild(nestedUl);

                     // --- Toggle Functionality ---
                     if (toggleIcon.classList.contains('toggle-icon')) { // Only add if it's a real toggle
                         toggleIcon.addEventListener('click', (e) => {
                             e.stopPropagation();
                             const isHidden = nestedUl.style.display === 'none';
                             nestedUl.style.display = isHidden ? 'block' : 'none';
                             toggleIcon.classList.replace(
                                 isHidden ? 'fa-chevron-right' : 'fa-chevron-down',
                                 isHidden ? 'fa-chevron-down' : 'fa-chevron-right'
                             );
                         });
                     }
                }
                parentUl.appendChild(li);
            });
        }


        // --- Rename Category Logic ---

        function showRenameInput(renameIcon) {
            const headerDiv = renameIcon.closest('.category-label');
            const labelSpan = headerDiv.querySelector('.label-text');
            const oldName = renameIcon.dataset.categoryName;

            // Prevent starting another rename if one is active
            if (headerDiv.querySelector('.rename-controls')) return;

            // Hide original label and rename icon
            labelSpan.classList.add('hidden');
            renameIcon.classList.add('hidden');

            // Create input field
            const input = document.createElement('input');
            input.type = 'text';
            input.value = oldName;
            input.classList.add('rename-input');
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') { handleRenameSave(input); }
                else if (e.key === 'Escape') { handleRenameCancel(input); }
            });

            // Create Save/Cancel buttons
            const saveBtn = document.createElement('button'); /* ... */
            saveBtn.classList.add('action-button', 'save-rename');
            saveBtn.innerHTML = '<i class="fas fa-check"></i>';
            saveBtn.title = 'Save new name';
            saveBtn.addEventListener('click', () => handleRenameSave(input));

            const cancelBtn = document.createElement('button'); /* ... */
            cancelBtn.classList.add('action-button', 'cancel-rename');
            cancelBtn.innerHTML = '<i class="fas fa-times"></i>';
            cancelBtn.title = 'Cancel rename';
            cancelBtn.addEventListener('click', () => handleRenameCancel(input));


            const controls = document.createElement('div');
            controls.classList.add('rename-controls');
            controls.appendChild(input);
            controls.appendChild(saveBtn);
            controls.appendChild(cancelBtn);

            headerDiv.insertBefore(controls, labelSpan);
            input.focus();
            input.select();
        }

        function handleRenameSave(inputElement) {
            const controlsDiv = inputElement.closest('.rename-controls');
            if (!controlsDiv) return; // Already removed
            const headerDiv = controlsDiv.closest('.category-label');
            const renameIcon = headerDiv.querySelector('.rename-icon');
            const oldName = renameIcon.dataset.categoryName;
            const fullPathString = renameIcon.dataset.fullPath; // Uses meta.hierarchy path now
            const newName = inputElement.value.trim();

            if (newName && newName !== oldName) {
                 try {
                     const fullPath = JSON.parse(fullPathString);
                     // Pass the *full* hierarchy path from meta
                     if (renameCategoryInData(fullPath, oldName, newName)) {
                        console.log(`Renamed category based on path [${fullPath.join('/')}] to "${newName}"`);
                        const treeData = buildUrlTree(classificationHistory);
                        renderTree(treeData, urlTreeContainer);
                     } else {
                        console.error("Failed to rename category in data (path/name mismatch?).");
                        handleRenameCancel(inputElement);
                     }
                 } catch (e) {
                     console.error("Error parsing path or renaming:", e);
                     handleRenameCancel(inputElement);
                 }
            } else {
                handleRenameCancel(inputElement);
            }
        }

        function handleRenameCancel(inputElement) {
            const controlsDiv = inputElement.closest('.rename-controls');
             if (!controlsDiv) return; // Avoid errors if called twice
            const headerDiv = controlsDiv.closest('.category-label');
            const labelSpan = headerDiv.querySelector('.label-text');
            const renameIcon = headerDiv.querySelector('.rename-icon');

            controlsDiv.remove();
            labelSpan.classList.remove('hidden');
            renameIcon.classList.remove('hidden');
        }

        // Updated renameCategoryInData to work with full meta hierarchy path
        function renameCategoryInData(fullHierarchyPath, oldName, newName) {
             if (!fullHierarchyPath || fullHierarchyPath.length === 0 || !oldName || !newName || oldName === newName) {
                 console.warn("Rename aborted: Invalid parameters.");
                 return false;
             }

             let changesMade = false;
             const renameLevelIndex = fullHierarchyPath.length - 1; // Index within the hierarchy array to change
             const targetUrlType = fullHierarchyPath[0]; // Expected URL type based on path

             classificationHistory.forEach(item => {
                 const classification = get(item, 'classification.classification');
                 if (!classification) return;

                 const itemUrlType = classification.url_type || 'Unknown Type';
                 const itemHierarchy = Array.isArray(classification.content_type_hierarchy)
                                       ? [...classification.content_type_hierarchy] // Copy
                                       : ['Unknown Category'];

                 // Match URL Type first
                 if (itemUrlType === targetUrlType) {
                     // Check if hierarchy is long enough and matches the prefix
                     if (itemHierarchy.length > renameLevelIndex) {
                         let prefixMatch = true;
                         for (let i = 0; i < renameLevelIndex; i++) {
                             // Check against the *provided* full path's prefix
                             if (itemHierarchy[i] !== fullHierarchyPath[i+1]) { // +1 because fullHierarchyPath includes urlType
                                 prefixMatch = false;
                                 break;
                             }
                         }

                         // Check the actual segment being renamed
                         if (prefixMatch && itemHierarchy[renameLevelIndex] === oldName) {
                             itemHierarchy[renameLevelIndex] = newName;
                             classification.content_type_hierarchy = itemHierarchy; // Update original object
                             changesMade = true;
                         }
                     }
                 }
                 // Note: Renaming url_type or format itself is not handled by this path logic easily
                 // Need separate UI/logic if renaming top-level types/formats is required.
             });

             if (changesMade) {
                 saveHistory();
             } else {
                  console.warn("Rename function executed, but no matching history entries found/modified for path:", fullHierarchyPath);
             }
             return changesMade;
        }

         // --- Drag and Drop Logic ---

         function moveHistoryEntry(entryId, targetUrlType, targetFormat, targetHierarchy) {
             const entryIndex = classificationHistory.findIndex(item => item.id === entryId);
             if (entryIndex === -1) {
                 console.error(`Cannot move entry: ID ${entryId} not found.`);
                 return false;
             }

             const entry = classificationHistory[entryIndex];
             const classification = get(entry, 'classification.classification');

             if (!classification) {
                 console.error(`Cannot move entry: Classification data missing for ID ${entryId}.`);
                 // Optionally create the structure if desired:
                 // entry.classification = { classification: {} };
                 // classification = entry.classification.classification;
                 return false;
             }

             // Update the classification data
             classification.url_type = targetUrlType;
             classification.content_format = targetFormat;
             classification.content_type_hierarchy = targetHierarchy;

             console.log(`Moved entry ${entryId} to [${targetUrlType}/${targetFormat}]/[${targetHierarchy.join('/')}]`);
             saveHistory();
             return true;
         }


        // --- Tab Switching Logic ---
        function switchTab(event) {
            // Clear any lingering drag states when switching tabs
            if (draggedElement) {
                 draggedElement.classList.remove('dragging');
                 draggedElement = null;
            }
            document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));

            const targetId = event.currentTarget.dataset.target;
            tabButtons.forEach(button => {
                button.classList.toggle('active', button.dataset.target === targetId);
            });
            pageContents.forEach(page => {
                page.classList.toggle('active', page.id === targetId);
            });
             if (targetId === 'treePage') {
                 const treeData = buildUrlTree(classificationHistory);
                 renderTree(treeData, urlTreeContainer);
             }
        }

        // --- Main Classification Function ---
        async function classifyUrlContent() {
            const pageUrl = urlInput.value.trim();
            if (!pageUrl || !/^https?:\/\/.+/.test(pageUrl)) {
                displayResultInArea(classifierResultDisplay, "Please enter a valid URL (starting with http:// or https://).", true);
                return;
            }
            showLoading(true);
            try {
                const response = await fetch(NETLIFY_FUNCTION_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url: pageUrl })
                });
                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error || `Function Error: ${response.status} ${response.statusText}`);
                }

                if (data.classification && typeof data.classification === 'object' && data.classification.classification) {
                    displayResultInArea(classifierResultDisplay, data.classification, false, 'API Result');
                    addHistoryEntry(pageUrl, data.classification);
                } else {
                     console.warn("Received unexpected response format:", data);
                     throw new Error("Received an unexpected response format from the classification service.");
                }
            } catch (error) {
                console.error("Error during classification:", error);
                displayResultInArea(classifierResultDisplay, `Classification failed: ${error.message}`, true);
            } finally {
                showLoading(false);
            }
        }

        // --- Initialization and Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            loadHistory();

            // Tab switching
            tabButtons.forEach(button => button.addEventListener('click', switchTab));

            // Classifier action
            classifyButton.addEventListener('click', classifyUrlContent);
            urlInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') { event.preventDefault(); classifyUrlContent(); }
            });

            // History actions
            clearHistoryButton.addEventListener('click', clearHistory);
            showAllButton.addEventListener('click', showAllHistory);

            // --- Event delegation for tree actions ---
            urlTreeContainer.addEventListener('click', (event) => {
                 // Handle Rename Icon Clicks
                 const renameIcon = event.target.closest('.rename-icon');
                 if (renameIcon) {
                      event.stopPropagation();
                      showRenameInput(renameIcon);
                      return;
                 }
                 // Note: Delete handled directly on button, Toggle handled directly on icon
            });

            // --- Drag and Drop Event Listeners (Delegated) ---
            urlTreeContainer.addEventListener('dragstart', (event) => {
                const targetLi = event.target.closest('li.url-link');
                if (targetLi && targetLi.draggable) {
                    draggedElement = targetLi; // Store ref to dragged element
                    const entryId = targetLi.dataset.entryId;
                    event.dataTransfer.setData(DRAG_DATA_TYPE, entryId);
                    event.dataTransfer.effectAllowed = 'move';
                    // Delay adding class slightly to ensure drag image is captured first
                    setTimeout(() => {
                        targetLi.classList.add('dragging');
                    }, 0);
                    console.log(`Drag Start: Entry ID ${entryId}`);
                }
            });

            urlTreeContainer.addEventListener('dragend', (event) => {
                 if (draggedElement) {
                     draggedElement.classList.remove('dragging');
                     draggedElement = null;
                     // Also remove any lingering drag-over styles
                     document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
                     console.log("Drag End");
                 }
            });

            urlTreeContainer.addEventListener('dragover', (event) => {
                const dropTarget = event.target.closest('.category-label');
                if (dropTarget && draggedElement) { // Check if dragging something valid
                    event.preventDefault(); // Necessary to allow dropping
                    event.dataTransfer.dropEffect = 'move';
                    dropTarget.classList.add('drag-over'); // Add visual cue
                }
            });

             urlTreeContainer.addEventListener('dragleave', (event) => {
                const dropTarget = event.target.closest('.category-label');
                 if (dropTarget) {
                    dropTarget.classList.remove('drag-over'); // Remove visual cue
                 }
            });

             urlTreeContainer.addEventListener('drop', (event) => {
                event.preventDefault(); // Prevent default drop behavior
                const dropTarget = event.target.closest('.category-label');
                 if (dropTarget && draggedElement) {
                     dropTarget.classList.remove('drag-over'); // Clean up visual cue

                     const entryId = event.dataTransfer.getData(DRAG_DATA_TYPE);
                     const targetUrlType = dropTarget.dataset.targetUrlType;
                     const targetFormat = dropTarget.dataset.targetFormat; // Correctly gets 'HTML' if needed
                     const targetHierarchy = JSON.parse(dropTarget.dataset.targetHierarchy);

                     console.log(`Drop: Entry ID ${entryId} onto Category [${targetUrlType}/${targetFormat}]/[${targetHierarchy.join('/')}]`);

                     if (entryId && targetUrlType && targetFormat && targetHierarchy) {
                          // Prevent dropping onto the exact same category? (Optional check)
                          // const sourceEntry = classificationHistory.find(item => item.id === entryId);
                          // const sourceClass = get(sourceEntry, 'classification.classification');
                          // if (sourceClass && sourceClass.url_type === targetUrlType && ...) { return; }

                         if (moveHistoryEntry(entryId, targetUrlType, targetFormat, targetHierarchy)) {
                             // Success: Re-render the tree
                             const treeData = buildUrlTree(classificationHistory);
                             renderTree(treeData, urlTreeContainer);
                         } else {
                             console.error("Failed to move history entry in data.");
                             // Optionally display an error message to the user
                         }
                     } else {
                         console.error("Drop failed: Missing data from dragged item or drop target.", { entryId, targetUrlType, targetFormat, targetHierarchy });
                     }
                 }
                 // Ensure dragging class is removed even if drop target is invalid
                 if (draggedElement) {
                     draggedElement.classList.remove('dragging');
                     draggedElement = null;
                 }
             });


            // Ensure default tab content is shown
            document.querySelector('.page-content.active') || document.getElementById('classifierPage').classList.add('active');
            document.querySelector('.tab-button.active') || document.querySelector('.tab-button[data-target="classifierPage"]').classList.add('active');
        });

    </script>
</body>
</html>