<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Page Classifier & History</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* --- Base Styles --- */
        :root {
            --primary: #2563eb;
            --primary-dark: #1d4ed8;
            --primary-light: #dbeafe;
            --success: #10b981;
            --success-dark: #047857;
            --success-light: #d1fae5;
            --danger: #ef4444;
            --danger-dark: #b91c1c;
            --danger-light: #fee2e2;
            --neutral-50: #f9fafb;
            --neutral-100: #f3f4f6;
            --neutral-200: #e5e7eb;
            --neutral-300: #d1d5db;
            --neutral-400: #9ca3af;
            --neutral-500: #6b7280;
            --neutral-600: #4b5563;
            --neutral-700: #374151;
            --neutral-800: #1f2937;
            --neutral-900: #111827;
            --info-light: #dbeafe;
            --info-dark: #1e3a8a;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.1);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1);
            --radius-sm: 0.25rem;
            --radius: 0.5rem;
            --radius-md: 0.75rem;
            --radius-lg: 1rem;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            background-color: var(--neutral-100);
            color: var(--neutral-800);
            padding: 20px;
            font-size: 16px;
        }

        .main-wrapper {
            background-color: #ffffff;
            padding: 0;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
            width: 100%;
            max-width: 900px;
            margin: 0 auto;
            overflow: hidden;
            position: relative;
            transition: box-shadow 0.3s ease;
        }

        .main-wrapper:hover {
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }

        /* --- Header --- */
        h1 {
            text-align: center;
            font-size: 1.8em;
            padding: 1.5rem 0;
            color: var(--primary);
            font-weight: 700;
            margin-bottom: 0;
            background-color: white;
            border-bottom: 1px solid var(--neutral-200);
        }

        h2 {
            font-size: 1.3em;
            margin-bottom: 1rem;
            text-align: left;
            color: var(--neutral-800);
            font-weight: 600;
        }

        /* --- Tab Navigation --- */
        .tab-container {
            display: flex;
            background-color: white;
            border-bottom: 1px solid var(--neutral-200);
            padding: 0 1rem;
        }

        .tab-button {
            padding: 1rem 1.25rem;
            cursor: pointer;
            border: none;
            background-color: transparent;
            font-size: 1rem;
            font-weight: 500;
            color: var(--neutral-600);
            transition: all 0.2s ease;
            border-bottom: 3px solid transparent;
            position: relative;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tab-button:hover {
            color: var(--primary);
            background-color: var(--neutral-50);
        }

        .tab-button.active {
            color: var(--primary);
            border-bottom: 3px solid var(--primary);
        }

        .tab-button.active::after {
            content: "";
            position: absolute;
            bottom: -3px;
            left: 0;
            right: 0;
            height: 3px;
            background-color: var(--primary);
            border-radius: 3px 3px 0 0;
        }

        .tab-button i {
            font-size: 0.9rem;
        }

        /* --- Page Content --- */
        .page-content {
            display: none;
            padding: 2rem;
            animation: fadeIn 0.3s ease;
        }

        .page-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* --- Form Elements --- */
        .form-group {
            margin-bottom: 1.5rem;
            text-align: left;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--neutral-700);
            font-size: 0.95rem;
        }

        input[type="url"], input[type="text"].rename-input {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 1px solid var(--neutral-300);
            border-radius: var(--radius);
            font-size: 1rem;
            font-family: inherit;
            transition: all 0.2s ease;
            background-color: white;
        }

        input[type="url"]:focus, input[type="text"].rename-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.15);
        }

        input[type="url"]::placeholder {
            color: var(--neutral-400);
        }

        button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 0.75rem 1.25rem;
            border-radius: var(--radius);
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        button:hover {
            background-color: var(--primary-dark);
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background-color: var(--neutral-400);
            cursor: not-allowed;
            transform: none;
        }

        button#classifyButton {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 150px;
            width: 100%;
        }

        /* Style for delete/action buttons in history and tree */
        .action-button {
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 0.1rem 0.3rem; /* Smaller padding */
            font-size: 0.85em; /* Slightly smaller icon */
            line-height: 1;
            margin-left: 0.3rem;
            vertical-align: middle;
        }
        .action-button.delete-button { color: var(--danger); }
        .action-button.delete-button:hover { color: var(--danger-dark); }
        .action-button.rename-icon { color: var(--neutral-500); }
        .action-button.rename-icon:hover { color: var(--primary); }
        .action-button.save-rename { color: var(--success); }
        .action-button.save-rename:hover { color: var(--success-dark); }
        .action-button.cancel-rename { color: var(--neutral-600); }
        .action-button.cancel-rename:hover { color: var(--neutral-800); }

        /* Container for inline rename controls */
        .rename-controls {
            display: inline-flex; /* Changed from flex to inline-flex */
            align-items: center;
            gap: 0.5rem;
            width: calc(100% - 30px); /* Adjust width as needed */
            margin-left: 0.5rem; /* Add some space */
        }
        .rename-controls input.rename-input {
            flex-grow: 1;
            font-size: 0.9em; /* Match surrounding text */
            padding: 0.3rem 0.5rem; /* Smaller padding */
            /* Remove width: 100% */
        }
        .rename-controls .action-button {
             margin-left: 0.1rem; /* Reduce margin */
        }


        /* --- Loader --- */
        .loader {
            border: 3px solid rgba(255,255,255,0.3);
            border-top: 3px solid white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            animation: spin 1s linear infinite;
            display: none;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* --- Info Boxes --- */
        .info {
            background-color: var(--info-light);
            color: var(--info-dark);
            border-left: 4px solid var(--primary);
            padding: 1rem;
            border-radius: var(--radius-sm);
            margin-bottom: 1.5rem;
            text-align: left;
            font-size: 0.95rem;
        }

        /* --- Result Display --- */
        .result-display-area {
            margin-top: 1.5rem;
            padding: 1.5rem;
            background-color: white;
            border-radius: var(--radius);
            border: 1px solid var(--neutral-200);
            text-align: left;
            word-wrap: break-word;
            display: none;
            font-size: 0.95em;
            min-height: 100px;
            box-shadow: var(--shadow-sm);
            transition: all 0.3s ease;
        }

        .result-display-area.error {
            background-color: var(--danger-light);
            color: var(--danger);
            border-left: 4px solid var(--danger);
        }

        .result-display-area strong.title {
            display: block;
            margin-bottom: 0.75rem;
            color: var(--primary);
            font-weight: 600;
            font-size: 1.1rem;
            border-bottom: 1px solid var(--neutral-200);
            padding-bottom: 0.75rem;
        }

        .result-display-area.error strong.title {
            color: var(--danger);
        }

        .result-display-area pre {
            background-color: var(--neutral-50);
            padding: 1rem;
            border-radius: var(--radius-sm);
            border: 1px solid var(--neutral-200);
            font-family: Monaco, Menlo, Consolas, "Liberation Mono", monospace;
            white-space: pre-wrap;
            word-break: break-all;
            font-size: 0.9rem;
            margin: 0;
            color: var(--neutral-800);
            overflow-x: auto;
            max-height: 400px;
            overflow-y: auto;
        }

        .result-display-area.error pre {
            color: var(--danger);
            background-color: transparent;
            border: none;
            padding: 0;
            white-space: pre-wrap;
            font-family: inherit;
            font-size: 1em;
        }

        /* --- History List --- */
        #historyList {
            list-style: none;
            padding: 0;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--neutral-200);
            border-radius: var(--radius);
            margin-bottom: 1rem;
            background-color: white;
        }

        #historyList li {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--neutral-200);
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            transition: background-color 0.2s ease;
            color: var(--neutral-700);
        }

        #historyList li:last-child {
            border-bottom: none;
        }

        #historyList li:hover {
            background-color: var(--neutral-100);
        }

        #historyList li.selected {
            background-color: var(--primary-light);
            color: var(--primary-dark);
            font-weight: 500;
            border-left: 4px solid var(--primary);
        }

        #historyList li:empty::after {
            content: "No history yet.";
            font-style: italic;
            color: var(--neutral-500);
            display: block;
            text-align: center;
            padding: 1.25rem;
        }
        /* Ensure delete button aligns correctly in list */
        #historyList .action-button.delete-button {
            margin-left: auto; /* Push delete button to the right */
            padding-left: 0.5rem; /* Add some space */
        }

        /* --- History Actions --- */
        .history-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            gap: 0.75rem;
        }

        .history-actions button {
            margin-top: 0;
            padding: 0.75rem 1rem;
            font-size: 0.9rem;
            flex-shrink: 0;
        }

        #showAllButton {
            background-color: var(--success);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        #showAllButton:hover {
            background-color: #0d9488;
        }

        #clearHistoryButton {
            background-color: var(--danger);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        #clearHistoryButton:hover {
            background-color: #b91c1c;
        }

        /* --- URL Tree --- */
        #urlTreeContainer {
            font-size: 0.95rem;
            border: 1px solid var(--neutral-200);
            padding: 1.5rem;
            border-radius: var(--radius);
            max-height: 500px;
            overflow: auto;
            background-color: white;
            box-shadow: var(--shadow-sm);
        }

        #urlTreeContainer ul {
            list-style: none;
            padding-left: 1.5rem;
            margin-top: 0.5rem;
        }

        #urlTreeContainer li {
            margin-bottom: 0.5rem;
            position: relative;
        }

        /* Folder toggle icon */
        .toggle-icon {
            cursor: pointer;
            margin-right: 0.5rem;
            width: 1em; /* Ensure consistent width */
            display: inline-block;
            text-align: center;
        }

        #urlTreeContainer li::before {
            content: "";
            position: absolute;
            left: -1rem;
            top: 0.7rem; /* Adjust if needed */
            width: 0.5rem;
            height: 0;
            border-top: 1px solid var(--neutral-300);
        }

        #urlTreeContainer ul > li::after {
            content: "";
            position: absolute;
            left: -1rem;
            top: 0;
            height: 100%;
            border-left: 1px solid var(--neutral-300);
        }

        #urlTreeContainer ul > li:last-child::after {
            height: 0.7rem; /* Adjust vertical line height for last item */
        }

        /* Style for category labels */
        #urlTreeContainer .category-label {
            font-weight: 600;
            color: var(--neutral-700);
            display: inline-flex; /* Use inline-flex to allow items side-by-side */
            align-items: center;
            margin-bottom: 0.3rem;
            padding: 0.25rem 0;
            position: relative; /* Needed for positioning rename controls */
            width: 100%; /* Take full width to contain inline elements */
        }
        #urlTreeContainer .category-label > .label-text {
             margin-right: 5px; /* Space between text and rename icon */
        }


        #urlTreeContainer .category-label::before {
            /* Using Font Awesome via class now, so remove this pseudo-element */
            /* content: "\f07b"; */
            /* font-family: "Font Awesome 6 Free"; */
            /* font-weight: 900; */
            /* margin-right: 0.5rem; */
            /* color: var(--primary); */
        }
         /* Add folder icon using FA class */
        #urlTreeContainer .category-label .folder-icon {
            margin-right: 0.5rem;
            color: var(--primary);
        }

        /* Style for URL links */
        #urlTreeContainer .url-link {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.25rem 0;
        }

        #urlTreeContainer .url-link a {
            color: var(--primary);
            text-decoration: none;
            word-break: break-all;
            font-size: 0.9rem;
            display: inline-flex;
            align-items: center;
            margin-right: 5px; /* Space before delete button */
        }

        #urlTreeContainer .url-link a::before {
            content: "\f0c1"; /* link icon */
            font-family: "Font Awesome 6 Free";
            font-weight: 900;
            margin-right: 0.5rem;
            font-size: 0.8rem;
            color: var(--neutral-500);
        }

        #urlTreeContainer .url-link a:hover {
            text-decoration: underline;
        }

        #urlTreeContainer .empty-tree {
            font-style: italic;
            color: var(--neutral-500);
            text-align: center;
            padding: 2rem;
        }

        /* Hidden utility class */
        .hidden {
            display: none !important;
        }

        /* --- Responsive Styles --- */
        @media (max-width: 768px) {
            .main-wrapper {
                border-radius: var(--radius);
            }

            .page-content {
                padding: 1.25rem;
            }
            #urlTreeContainer .category-label,
            #urlTreeContainer .url-link a {
                 max-width: calc(100% - 40px); /* Prevent overlap with buttons */
            }
        }

        @media (max-width: 600px) {
            body {
                padding: 10px;
            }

            h1 {
                font-size: 1.5rem;
                padding: 1rem 0;
            }

            .tab-button {
                padding: 0.75rem 0.5rem;
                font-size: 0.85rem;
            }

            .tab-container {
                padding: 0;
            }

            .tab-button i {
                margin-right: 0;
            }

            .tab-button span {
                display: none;
            }

            .history-actions {
                flex-direction: column;
            }

            .history-actions button {
                width: 100%;
            }

            #urlTreeContainer ul {
                padding-left: 1rem;
            }

            .result-display-area pre {
                font-size: 0.8rem;
            }
             /* Adjust rename controls for small screens */
            .rename-controls {
                width: calc(100% - 20px); /* Ensure it fits */
            }
             #urlTreeContainer .category-label,
             #urlTreeContainer .url-link a {
                  max-width: calc(100% - 50px); /* More aggressive on small screens */
             }
        }
    </style>
</head>
<body>
    <div class="main-wrapper">
        <h1>Web Page Classifier</h1>

        <!-- Tab Navigation -->
        <div class="tab-container">
            <button class="tab-button active" data-target="classifierPage">
                <i class="fas fa-magnifying-glass"></i>
                <span>Classifier</span>
            </button>
            <button class="tab-button" data-target="historyPage">
                <i class="fas fa-clock-rotate-left"></i>
                <span>History</span>
            </button>
            <button class="tab-button" data-target="treePage">
                <i class="fas fa-sitemap"></i>
                <span>URL Tree</span>
            </button>
        </div>

        <!-- Classifier Page Content -->
        <div id="classifierPage" class="page-content active">
            <div class="info">
                <i class="fas fa-circle-info"></i> Enter a URL. The classification result (JSON) will be displayed below and saved to history.
            </div>
            <div class="form-group">
                <label for="pageUrl">Web Page URL:</label>
                <input type="url" id="pageUrl" placeholder="https://example.com/article" required>
            </div>
            <button id="classifyButton">
                <div class="loader" id="loader"></div>
                <span>Classify URL</span>
            </button>
            <div id="classifierResultDisplay" class="result-display-area">
                <strong class="title">Result:</strong>
                <pre></pre>
            </div>
        </div>

        <!-- History Page Content -->
        <div id="historyPage" class="page-content">
            <h2>Classification History List</h2>
            <ul id="historyList"><li></li></ul> <!-- Initial empty li placeholder handled by JS -->
            <div class="history-actions">
                <button id="showAllButton">
                    <i class="fas fa-list"></i>
                    <span>Show All URLs & Classifications</span>
                </button>
                <button id="clearHistoryButton">
                    <i class="fas fa-trash-can"></i>
                    <span>Clear History</span>
                </button>
            </div>
            <div id="historyResultDisplay" class="result-display-area">
                <strong class="title">Selected / All History:</strong>
                <pre></pre>
            </div>
        </div>

        <!-- Tree Page Content -->
        <div id="treePage" class="page-content">
            <h2>URL Classification Tree</h2>
            <div class="info">
                <i class="fas fa-circle-info"></i> URLs are categorized. Click <i class="fas fa-chevron-down"></i>/<i class="fas fa-chevron-right"></i> to fold/unfold. Click <i class="fas fa-pencil-alt"></i> to rename a category. Click <i class="fas fa-trash-alt"></i> to remove a URL entry.
            </div>
            <div id="urlTreeContainer">
                <!-- Tree will be rendered here by JavaScript -->
            </div>
        </div>

    </div> <!-- End main-wrapper -->

    <script>
        // --- Configuration ---
        const NETLIFY_FUNCTION_ENDPOINT = '/.netlify/functions/classify-url';
        const LOCAL_STORAGE_KEY = 'urlClassificationHistory';

        // --- DOM Elements ---
        const classifyButton = document.getElementById('classifyButton');
        const urlInput = document.getElementById('pageUrl');
        const loader = document.getElementById('loader');
        const buttonText = classifyButton.querySelector('span');
        const classifierResultDisplay = document.getElementById('classifierResultDisplay');
        const historyResultDisplay = document.getElementById('historyResultDisplay');
        const historyList = document.getElementById('historyList');
        const clearHistoryButton = document.getElementById('clearHistoryButton');
        const showAllButton = document.getElementById('showAllButton');
        const urlTreeContainer = document.getElementById('urlTreeContainer');
        const tabButtons = document.querySelectorAll('.tab-button');
        const pageContents = document.querySelectorAll('.page-content');

        // --- State ---
        let classificationHistory = []; // In-memory copy

        // --- Helper: Generate Unique ID ---
        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substring(2);
        }

        // --- Functions ---

        function showLoading(isLoading) {
            if (isLoading) {
                classifyButton.disabled = true;
                loader.style.display = 'inline-block';
                buttonText.textContent = 'Classifying...';
                classifierResultDisplay.style.display = 'none';
                classifierResultDisplay.classList.remove('error');
            } else {
                classifyButton.disabled = false;
                loader.style.display = 'none';
                buttonText.textContent = 'Classify URL';
            }
        }

        function displayResultInArea(areaElement, data, isError = false, titlePrefix = 'Result') {
            areaElement.innerHTML = ''; // Clear previous content
            areaElement.style.display = 'block';
            const title = document.createElement('strong');
            title.classList.add('title');
            const resultOutput = document.createElement('pre');
            if (isError) {
                areaElement.classList.add('error');
                title.textContent = `Error:`;
                resultOutput.textContent = (typeof data === 'string') ? data : JSON.stringify(data, null, 2);
            } else {
                areaElement.classList.remove('error');
                title.textContent = `${titlePrefix}:`;
                resultOutput.textContent = JSON.stringify(data, null, 2);
            }
            areaElement.appendChild(title);
            areaElement.appendChild(resultOutput);
        }

        // Delete an entry from history by id (used by both history list and tree view)
        function deleteHistoryEntryById(entryId) {
            const initialLength = classificationHistory.length;
            classificationHistory = classificationHistory.filter(entry => entry.id !== entryId);
            if (classificationHistory.length < initialLength) {
                saveHistory();
                renderHistoryList();
                // Rebuild tree to reflect deletion
                const treeData = buildUrlTree(classificationHistory);
                renderTree(treeData, urlTreeContainer);
                 // Hide history display if the deleted item was selected
                 historyResultDisplay.style.display = 'none';
                 document.querySelectorAll('#historyList li.selected').forEach(el => el.classList.remove('selected'));
                 console.log(`Deleted history entry ${entryId}`);
            } else {
                console.warn(`Attempted to delete non-existent entry ${entryId}`);
            }
        }

        // --- History List Rendering and Management ---

        function renderHistoryList() {
            historyList.innerHTML = ''; // Clear previous list
            if (classificationHistory.length === 0) {
                const emptyLi = document.createElement('li');
                emptyLi.textContent = "No history yet.";
                emptyLi.style.fontStyle = "italic";
                emptyLi.style.color = "var(--neutral-500)";
                emptyLi.style.textAlign = "center";
                emptyLi.style.cursor = "default";
                historyList.appendChild(emptyLi);
                return;
            }
            // Sort history by most recent first (optional, assuming IDs are time-based)
            // const sortedHistory = [...classificationHistory].sort((a, b) => (b.id < a.id ? -1 : 1));

            classificationHistory.forEach((item) => {
                const li = document.createElement('li');
                const textSpan = document.createElement('span'); // Span for text content
                textSpan.textContent = item.url;
                textSpan.style.overflow = 'hidden';
                textSpan.style.textOverflow = 'ellipsis';
                textSpan.style.whiteSpace = 'nowrap';
                textSpan.title = item.url; // Tooltip for full URL
                li.appendChild(textSpan);

                li.dataset.id = item.id;

                // Delete button for history entry
                const delBtn = document.createElement('button');
                delBtn.classList.add('action-button', 'delete-button');
                delBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
                delBtn.title = "Delete this entry"; // Tooltip
                delBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent li click event
                    deleteHistoryEntryById(item.id);
                });

                li.appendChild(delBtn); // Append delete button

                li.addEventListener('click', () => {
                    // Don't select if clicking the delete button (already handled by stopPropagation)
                    document.querySelectorAll('#historyList li.selected').forEach(el => el.classList.remove('selected'));
                    li.classList.add('selected');
                    if (item.classification) {
                        displayResultInArea(historyResultDisplay, item.classification, false, `Selected: ${item.url}`);
                    } else {
                        displayResultInArea(historyResultDisplay, "Classification data missing for this entry.", true, `Selected: ${item.url}`);
                    }
                });
                historyList.appendChild(li);
            });
        }

        function loadHistory() {
            try {
                const storedHistory = localStorage.getItem(LOCAL_STORAGE_KEY);
                classificationHistory = storedHistory ? JSON.parse(storedHistory) : [];
                 // Basic validation: ensure it's an array
                 if (!Array.isArray(classificationHistory)) {
                     console.warn("Stored history was not an array, resetting.");
                     classificationHistory = [];
                     localStorage.removeItem(LOCAL_STORAGE_KEY); // Clear invalid data
                 }
            } catch (error) {
                console.error("Error loading/parsing history:", error);
                classificationHistory = [];
            }
            renderHistoryList();
            // Build and render the tree after loading history
            const treeData = buildUrlTree(classificationHistory);
            renderTree(treeData, urlTreeContainer);
        }

        function saveHistory() {
            try {
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(classificationHistory));
            } catch (error) {
                console.error("Error saving history:", error);
                displayResultInArea(classifierResultDisplay, "Could not save history (Storage might be full).", true);
            }
        }

        function addHistoryEntry(url, classificationData) {
            // Optional: Check if URL already exists and update instead? For now, just add.
            const newEntry = { id: generateId(), url: url, classification: classificationData };
            classificationHistory.unshift(newEntry); // Add to the beginning
            saveHistory();
            renderHistoryList();
            // Re-build and re-render the tree
            const treeData = buildUrlTree(classificationHistory);
            renderTree(treeData, urlTreeContainer);
        }

        function showAllHistory() {
            if (classificationHistory.length === 0) {
                displayResultInArea(historyResultDisplay, "History is empty.", true, "Full History");
            } else {
                // Display a copy to avoid showing the internal `id` unnecessarily to the user if desired
                 const displayHistory = classificationHistory.map(({ id, ...rest }) => rest);
                 displayResultInArea(historyResultDisplay, displayHistory, false, "All Stored Classifications");
            }
            document.querySelectorAll('#historyList li.selected').forEach(el => el.classList.remove('selected'));
        }

        function clearHistory() {
            if (confirm("Are you sure you want to clear the entire classification history? This cannot be undone.")) {
                classificationHistory = [];
                saveHistory();
                renderHistoryList();
                historyResultDisplay.style.display = 'none';
                // Clear the tree view
                urlTreeContainer.innerHTML = '<div class="empty-tree">History cleared.</div>';
            }
        }


        // --- Tree Building and Rendering Logic ---

        // Helper to safely get nested properties
        const get = (obj, path, defaultValue = undefined) => {
          const travel = (regexp) =>
            String.prototype.split
              .call(path, regexp)
              .filter(Boolean)
              .reduce((res, key) => (res !== null && res !== undefined ? res[key] : res), obj);
          const result = travel(/[,[\]]+?/) || travel(/[,[\].]+?/);
          return result === undefined || result === obj ? defaultValue : result;
        };


        function buildUrlTree(history) {
            const tree = {}; // Root of the tree

            history.forEach(item => {
                const classification = get(item, 'classification.classification'); // Use safe getter
                if (!classification) return; // Skip if classification structure is missing

                // Ensure default values if properties are missing
                const urlType = classification.url_type || 'Unknown Type';
                const format = classification.content_format || 'Unknown Format';
                const hierarchy = Array.isArray(classification.content_type_hierarchy) && classification.content_type_hierarchy.length > 0
                                  ? classification.content_type_hierarchy
                                  : ['Unknown Category'];

                let currentLevel = tree;

                // Level 1: URL Type
                if (!currentLevel[urlType]) currentLevel[urlType] = {};
                currentLevel = currentLevel[urlType];

                // Level 2: Content Format (Conditional based on 'HTML')
                let formatKey = format;
                 // Always add the format level unless it's exactly 'HTML' (case-insensitive check)
                 if (format.trim().toLowerCase() !== 'html') {
                     if (!currentLevel[formatKey]) currentLevel[formatKey] = {};
                     currentLevel = currentLevel[formatKey];
                 }
                 // If it IS 'HTML', currentLevel remains the urlTypeBranch, effectively skipping the 'HTML' node visually


                // Levels 3+: Content Type Hierarchy
                hierarchy.forEach((category, index) => {
                    const isLastLevel = index === hierarchy.length - 1;
                    if (!currentLevel[category]) {
                         // Create an array for the last level, object for intermediate
                         currentLevel[category] = isLastLevel ? [] : {};
                    }

                    if (isLastLevel) {
                        // Ensure it's an array (might have been object previously if hierarchy changed)
                         if (!Array.isArray(currentLevel[category])) {
                             currentLevel[category] = [];
                         }
                         // Add the URL entry (object with id and url) if not already present.
                         if (!currentLevel[category].some(entry => entry.id === item.id)) {
                             currentLevel[category].push({ id: item.id, url: item.url });
                         }
                    } else {
                         // Ensure it's an object (might have been array previously if hierarchy changed)
                         if (typeof currentLevel[category] !== 'object' || Array.isArray(currentLevel[category])) {
                              currentLevel[category] = {};
                         }
                         currentLevel = currentLevel[category];
                    }
                });
            });
            // console.log("Built Tree:", JSON.stringify(tree, null, 2)); // Detailed log if needed
            return tree;
        }

        // Render the tree recursively.
        function renderTree(treeData, containerElement) {
            containerElement.innerHTML = ''; // Clear previous tree
            if (Object.keys(treeData).length === 0) {
                containerElement.innerHTML = '<div class="empty-tree">No classification data available to build the tree.</div>';
                return;
            }
            const rootUl = document.createElement('ul');
            containerElement.appendChild(rootUl);
            // Start rendering from the root, with an empty initial path
            renderTreeNode(treeData, rootUl, []);
        }

        // Modified renderTreeNode to include path tracking and rename elements
        function renderTreeNode(node, parentUl, currentPath) {
            const categories = Object.keys(node).sort();

            categories.forEach(category => {
                const li = document.createElement('li');
                const nodeValue = node[category];
                const isFolder = typeof nodeValue === 'object' && !Array.isArray(nodeValue);
                const isLeafList = Array.isArray(nodeValue); // List of URL entries

                // --- Create Header (for folders and leaf lists) ---
                const header = document.createElement('div');
                header.classList.add('category-label'); // Common class for styling

                // Toggle Icon (always present for folders/leaf lists)
                const toggleIcon = document.createElement('i');
                toggleIcon.classList.add('toggle-icon', 'fas', 'fa-chevron-down'); // Default open

                // Folder/File Icon & Label Text Span
                const iconSpan = document.createElement('i');
                const labelSpan = document.createElement('span');
                labelSpan.classList.add('label-text');
                labelSpan.textContent = category;

                if (isFolder || isLeafList) {
                    iconSpan.classList.add('fas', 'fa-folder', 'folder-icon'); // Folder icon for categories
                }
                // else { // This case shouldn't happen with the current build logic
                //    iconSpan.classList.add('fas', 'fa-file', 'file-icon'); // File icon (if we had single items not in arrays)
                // }

                header.appendChild(toggleIcon);
                header.appendChild(iconSpan);
                header.appendChild(labelSpan);

                // --- Add Rename Icon (only for actual category folders/leaf lists) ---
                 if (isFolder || isLeafList) {
                     const renameIcon = document.createElement('button');
                     renameIcon.classList.add('action-button', 'rename-icon');
                     renameIcon.innerHTML = '<i class="fas fa-pencil-alt"></i>';
                     renameIcon.title = `Rename category "${category}"`;
                     // Store data needed for renaming
                     renameIcon.dataset.categoryName = category;
                     // Store the full path to *this* category node
                     renameIcon.dataset.fullPath = JSON.stringify([...currentPath, category]);
                     header.appendChild(renameIcon);
                 }


                li.appendChild(header);

                // --- Create Nested List (ul) for Children ---
                let nestedUl = null;
                if (isFolder || isLeafList) {
                    nestedUl = document.createElement('ul');
                    if (isFolder) {
                        // Recursively render child categories, extending the path
                        renderTreeNode(nodeValue, nestedUl, [...currentPath, category]);
                    } else { // isLeafList
                        // Sort URLs alphabetically
                        nodeValue.sort((a, b) => a.url.localeCompare(b.url)).forEach(entry => {
                            const urlLi = document.createElement('li');
                            urlLi.classList.add('url-link');

                            const link = document.createElement('a');
                            link.href = entry.url;
                            link.textContent = entry.url;
                            link.title = entry.url;
                            link.target = '_blank';
                            link.rel = 'noopener noreferrer';
                            urlLi.appendChild(link);

                            const deleteBtn = document.createElement('button');
                            deleteBtn.classList.add('action-button', 'delete-button');
                            deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
                            deleteBtn.title = "Delete this URL entry";
                            deleteBtn.dataset.entryId = entry.id; // Store ID for deletion
                            deleteBtn.addEventListener('click', (e) => {
                                e.stopPropagation();
                                deleteHistoryEntryById(entry.id);
                            });
                            urlLi.appendChild(deleteBtn);
                            nestedUl.appendChild(urlLi);
                        });
                    }
                     li.appendChild(nestedUl);

                     // --- Toggle Functionality ---
                     toggleIcon.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const isHidden = nestedUl.style.display === 'none';
                        nestedUl.style.display = isHidden ? 'block' : 'none';
                        toggleIcon.classList.replace(
                            isHidden ? 'fa-chevron-right' : 'fa-chevron-down',
                            isHidden ? 'fa-chevron-down' : 'fa-chevron-right'
                        );
                     });
                }
                parentUl.appendChild(li);
            });
        }


        // --- Rename Category Logic ---

        function showRenameInput(renameIcon) {
            const headerDiv = renameIcon.closest('.category-label');
            const labelSpan = headerDiv.querySelector('.label-text');
            const oldName = renameIcon.dataset.categoryName;

            // Hide original label and rename icon
            labelSpan.classList.add('hidden');
            renameIcon.classList.add('hidden');

            // Create input field
            const input = document.createElement('input');
            input.type = 'text';
            input.value = oldName;
            input.classList.add('rename-input');
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    handleRenameSave(input);
                } else if (e.key === 'Escape') {
                    handleRenameCancel(input);
                }
            });

            // Create Save button
            const saveBtn = document.createElement('button');
            saveBtn.classList.add('action-button', 'save-rename');
            saveBtn.innerHTML = '<i class="fas fa-check"></i>';
            saveBtn.title = 'Save new name';
            saveBtn.addEventListener('click', () => handleRenameSave(input));

            // Create Cancel button
            const cancelBtn = document.createElement('button');
            cancelBtn.classList.add('action-button', 'cancel-rename');
            cancelBtn.innerHTML = '<i class="fas fa-times"></i>';
            cancelBtn.title = 'Cancel rename';
            cancelBtn.addEventListener('click', () => handleRenameCancel(input));

            // Add controls container
            const controls = document.createElement('div');
            controls.classList.add('rename-controls');
            controls.appendChild(input);
            controls.appendChild(saveBtn);
            controls.appendChild(cancelBtn);

            // Insert controls after the folder icon
            headerDiv.insertBefore(controls, labelSpan); // Insert before the (now hidden) label
            input.focus();
            input.select();
        }

        function handleRenameSave(inputElement) {
            const controlsDiv = inputElement.closest('.rename-controls');
            const headerDiv = controlsDiv.closest('.category-label');
            const renameIcon = headerDiv.querySelector('.rename-icon'); // Find original icon to get data
            const oldName = renameIcon.dataset.categoryName;
            const fullPathString = renameIcon.dataset.fullPath;
            const newName = inputElement.value.trim();

            if (newName && newName !== oldName) {
                 try {
                     const fullPath = JSON.parse(fullPathString);
                     if (renameCategoryInData(fullPath, oldName, newName)) {
                        // Success: Data updated, history saved, tree will be re-rendered
                        console.log(`Renamed category "${oldName}" at path [${fullPath.join('/')}] to "${newName}"`);
                        // Re-render the tree immediately
                        const treeData = buildUrlTree(classificationHistory);
                        renderTree(treeData, urlTreeContainer);
                        // No need to manually remove controls, re-render handles it.
                     } else {
                        // Failed to update data (shouldn't normally happen if path is correct)
                        console.error("Failed to rename category in data.");
                        // Restore UI in case of failure
                        handleRenameCancel(inputElement);
                     }
                 } catch (e) {
                     console.error("Error parsing path or renaming:", e);
                     handleRenameCancel(inputElement); // Restore UI on error
                 }
            } else {
                // No change or empty name, treat as cancel
                handleRenameCancel(inputElement);
            }
        }

        function handleRenameCancel(inputElement) {
            const controlsDiv = inputElement.closest('.rename-controls');
            const headerDiv = controlsDiv.closest('.category-label');
            const labelSpan = headerDiv.querySelector('.label-text');
            const renameIcon = headerDiv.querySelector('.rename-icon');

            // Remove rename controls
            controlsDiv.remove();

            // Show original label and icon
            labelSpan.classList.remove('hidden');
            renameIcon.classList.remove('hidden');
        }

        // Updates classificationHistory based on rename operation
        // Returns true if any changes were made, false otherwise.
        function renameCategoryInData(fullPath, oldName, newName) {
            if (!fullPath || fullPath.length === 0 || !oldName || !newName || oldName === newName) {
                console.warn("Rename aborted: Invalid parameters.");
                return false;
            }

            let changesMade = false;
            const pathLength = fullPath.length;

            // Path structure: [url_type, (optional) format, hierarchy_part1, hierarchy_part2, ...]
            const urlTypePath = fullPath[0];
            let formatPath = null;
            let hierarchyStartIndex = 1; // Index where hierarchy starts in fullPath

             // Determine if format is part of the path (exists and is not 'html' case-insensitive)
             if (pathLength > 1) {
                  const potentialFormat = fullPath[1];
                  // Check against original history data format, not just the path segment
                  // This requires knowing if the *original* format was HTML or not.
                  // Simpler: Assume path reflects visual tree. If path has 2+ elements
                  // AND the 2nd element doesn't correspond to the start of hierarchy for
                  // items classified as 'HTML', then the 2nd element IS the format.
                  // Let's refine based on how buildUrlTree works:
                  // The path passed *always* includes the category name itself.
                  // The path *won't* include 'HTML' if that was skipped visually.
                  // So, we need to compare against the *actual* history data.

                  // Let's iterate history and check consistency
                  const firstItemMatch = classificationHistory.find(item => {
                      const classification = get(item, 'classification.classification');
                      return classification && classification.url_type === urlTypePath;
                  });

                 if (firstItemMatch) {
                      const itemFormat = get(firstItemMatch, 'classification.classification.content_format', '').trim().toLowerCase();
                      if (itemFormat !== 'html' && fullPath.length > 1 && get(firstItemMatch, 'classification.classification.content_format') === fullPath[1]) {
                          // The second path element IS the format (and it's not HTML)
                          formatPath = fullPath[1];
                          hierarchyStartIndex = 2;
                      } else if (itemFormat === 'html') {
                           // The format in data is HTML (so it was skipped in the tree path)
                           formatPath = 'HTML'; // We know the expected format for matching
                           hierarchyStartIndex = 1; // Hierarchy starts at index 1 in path
                      } else {
                           // Format is not HTML, but wasn't the 2nd path element (e.g., only url_type and hierarchy)
                           formatPath = get(firstItemMatch, 'classification.classification.content_format'); // Use actual format for matching
                           hierarchyStartIndex = 1; // Hierarchy starts at index 1
                      }
                 } else {
                     // No matching items found? Can't determine format context. Abort.
                      console.warn("Rename aborted: Cannot determine context, no items match URL type.");
                      return false;
                 }

             } else {
                 // Path only has url_type, renaming the url_type itself.
                 hierarchyStartIndex = -1; // Indicate we're renaming url_type
             }


            const targetHierarchyPath = fullPath.slice(hierarchyStartIndex);
            const renameLevelIndex = targetHierarchyPath.length - 1; // Index within the *hierarchy array*

            classificationHistory.forEach(item => {
                const classification = get(item, 'classification.classification');
                if (!classification) return;

                const itemUrlType = classification.url_type || 'Unknown Type';
                const itemFormat = classification.content_format || 'Unknown Format';
                const itemHierarchy = Array.isArray(classification.content_type_hierarchy)
                                      ? [...classification.content_type_hierarchy] // Operate on a copy
                                      : ['Unknown Category'];

                let match = false;

                // Match URL Type
                if (itemUrlType === urlTypePath) {
                    // If renaming url_type itself (hierarchyStartIndex is -1)
                    if (hierarchyStartIndex === -1 && oldName === urlTypePath) {
                         classification.url_type = newName;
                         changesMade = true;
                         match = true; // Mark as matched for this item
                    }
                    // Match Format (if applicable)
                    else if (formatPath === null || itemFormat === formatPath) {
                         // Match Hierarchy Path up to the rename level
                         if (renameLevelIndex >= 0 && itemHierarchy.length > renameLevelIndex) {
                             let prefixMatch = true;
                             for (let i = 0; i < renameLevelIndex; i++) {
                                 if (itemHierarchy[i] !== targetHierarchyPath[i]) {
                                     prefixMatch = false;
                                     break;
                                 }
                             }
                              // Check the actual segment being renamed
                             if (prefixMatch && itemHierarchy[renameLevelIndex] === oldName) {
                                 itemHierarchy[renameLevelIndex] = newName;
                                 classification.content_type_hierarchy = itemHierarchy; // Update the original object
                                 changesMade = true;
                                 match = true; // Mark as matched
                             }
                         }
                    }
                     // Check if renaming the format itself
                     else if (formatPath !== null && hierarchyStartIndex === 2 && renameLevelIndex === -1 && oldName === itemFormat) {
                         // This case occurs if the path was [urlType, formatName]
                         classification.content_format = newName;
                         changesMade = true;
                         match = true;
                     }
                }

                // if (match) {
                //     console.log(`Updated item ${item.id} (${item.url})`);
                // }
            });

            if (changesMade) {
                saveHistory(); // Persist changes
            } else {
                 console.warn("Rename function executed, but no matching history entries were found or modified for path:", fullPath);
            }

            return changesMade;
        }

        // --- Tab Switching Logic ---
        function switchTab(event) {
            const targetId = event.currentTarget.dataset.target;
            tabButtons.forEach(button => {
                button.classList.toggle('active', button.dataset.target === targetId);
            });
            pageContents.forEach(page => {
                page.classList.toggle('active', page.id === targetId);
            });
            // Optionally re-render tree if switching to that tab, in case data changed externally
             if (targetId === 'treePage') {
                 const treeData = buildUrlTree(classificationHistory);
                 renderTree(treeData, urlTreeContainer);
             }
        }

        // --- Main Classification Function ---
        async function classifyUrlContent() {
            const pageUrl = urlInput.value.trim();
            if (!pageUrl || !/^https?:\/\/.+/.test(pageUrl)) {
                displayResultInArea(classifierResultDisplay, "Please enter a valid URL (starting with http:// or https://).", true);
                return;
            }
            showLoading(true);
            try {
                const response = await fetch(NETLIFY_FUNCTION_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url: pageUrl })
                });
                const data = await response.json(); // Always parse JSON first

                if (!response.ok) {
                    // Use error message from JSON if available, otherwise status text
                    throw new Error(data.error || `Function Error: ${response.status} ${response.statusText}`);
                }

                // Check if the expected structure is present
                if (data.classification && typeof data.classification === 'object' && data.classification.classification) {
                    displayResultInArea(classifierResultDisplay, data.classification, false, 'API Result');
                    addHistoryEntry(pageUrl, data.classification); // Save the whole object returned
                } else {
                     // Got a 200 OK, but the content wasn't as expected
                     console.warn("Received unexpected response format:", data);
                     throw new Error("Received an unexpected response format from the classification service.");
                }
            } catch (error) {
                console.error("Error during classification:", error);
                // Display specific error from fetch/function or a generic one
                displayResultInArea(classifierResultDisplay, `Classification failed: ${error.message}`, true);
            } finally {
                showLoading(false);
            }
        }

        // --- Initialization and Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            loadHistory(); // Load data when the page is ready

            // Tab switching
            tabButtons.forEach(button => button.addEventListener('click', switchTab));

            // Classifier action
            classifyButton.addEventListener('click', classifyUrlContent);
            urlInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    classifyUrlContent();
                }
            });

            // History actions
            clearHistoryButton.addEventListener('click', clearHistory);
            showAllButton.addEventListener('click', showAllHistory);

            // Event delegation for tree actions (rename)
            urlTreeContainer.addEventListener('click', (event) => {
                 // Handle Rename Icon Clicks
                 const renameIcon = event.target.closest('.rename-icon');
                 if (renameIcon) {
                      event.stopPropagation(); // Prevent other clicks if needed
                      showRenameInput(renameIcon);
                      return; // Stop processing here
                 }

                 // Note: Delete button clicks inside the tree are handled directly
                 // on the button elements during renderTreeNode, no delegation needed here.
            });

            // Ensure default tab content is shown (redundant if HTML has `active` class, but safe)
            document.querySelector('.page-content.active') || document.getElementById('classifierPage').classList.add('active');
            document.querySelector('.tab-button.active') || document.querySelector('.tab-button[data-target="classifierPage"]').classList.add('active');
        });

    </script>
</body>
</html>