<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Page Classifier & History</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* --- Base Styles --- */
        :root {
            --primary: #2563eb;
            --primary-dark: #1d4ed8;
            --primary-light: #dbeafe;
            --success: #10b981;
            --success-dark: #047857;
            --success-light: #d1fae5;
            --danger: #ef4444;
            --danger-dark: #b91c1c;
            --danger-light: #fee2e2;
            --warning: #f59e0b; /* Added for create folder icon */
            --warning-dark: #b45309;
            --neutral-50: #f9fafb;
            --neutral-100: #f3f4f6;
            --neutral-200: #e5e7eb;
            --neutral-300: #d1d5db;
            --neutral-400: #9ca3af;
            --neutral-500: #6b7280;
            --neutral-600: #4b5563;
            --neutral-700: #374151;
            --neutral-800: #1f2937;
            --neutral-900: #111827;
            --info-light: #dbeafe;
            --info-dark: #1e3a8a;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.1);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1);
            --radius-sm: 0.25rem;
            --radius: 0.5rem;
            --radius-md: 0.75rem;
            --radius-lg: 1rem;
        }

        /* ... (rest of CSS styles remain exactly the same as previous version) ... */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            background-color: var(--neutral-100);
            color: var(--neutral-800);
            padding: 20px;
            font-size: 16px;
        }

        .main-wrapper {
            background-color: #ffffff;
            padding: 0;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
            width: 100%;
            max-width: 900px;
            margin: 0 auto;
            overflow: hidden;
            position: relative;
            transition: box-shadow 0.3s ease;
        }

        .main-wrapper:hover {
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }

        /* --- Header --- */
        h1 {
            text-align: center;
            font-size: 1.8em;
            padding: 1.5rem 0;
            color: var(--primary);
            font-weight: 700;
            margin-bottom: 0;
            background-color: white;
            border-bottom: 1px solid var(--neutral-200);
        }

        h2 {
            font-size: 1.3em;
            margin-bottom: 1rem;
            text-align: left;
            color: var(--neutral-800);
            font-weight: 600;
        }

        /* --- Tab Navigation --- */
        .tab-container {
            display: flex;
            background-color: white;
            border-bottom: 1px solid var(--neutral-200);
            padding: 0 1rem;
        }

        .tab-button {
            padding: 1rem 1.25rem;
            cursor: pointer;
            border: none;
            background-color: transparent;
            font-size: 1rem;
            font-weight: 500;
            color: var(--neutral-600);
            transition: all 0.2s ease;
            border-bottom: 3px solid transparent;
            position: relative;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tab-button:hover {
            color: var(--primary);
            background-color: var(--neutral-50);
        }

        .tab-button.active {
            color: var(--primary);
            border-bottom: 3px solid var(--primary);
        }

        .tab-button.active::after {
            content: "";
            position: absolute;
            bottom: -3px;
            left: 0;
            right: 0;
            height: 3px;
            background-color: var(--primary);
            border-radius: 3px 3px 0 0;
        }

        .tab-button i {
            font-size: 0.9rem;
        }

        /* --- Page Content --- */
        .page-content {
            display: none;
            padding: 2rem;
            animation: fadeIn 0.3s ease;
        }

        .page-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* --- Form Elements --- */
        .form-group {
            margin-bottom: 1.5rem;
            text-align: left;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--neutral-700);
            font-size: 0.95rem;
        }

        input[type="url"], input[type="text"].rename-input {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 1px solid var(--neutral-300);
            border-radius: var(--radius);
            font-size: 1rem;
            font-family: inherit;
            transition: all 0.2s ease;
            background-color: white;
        }

        input[type="url"]:focus, input[type="text"].rename-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.15);
        }

        input[type="url"]::placeholder {
            color: var(--neutral-400);
        }

        button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 0.75rem 1.25rem;
            border-radius: var(--radius);
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        button:hover {
            background-color: var(--primary-dark);
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background-color: var(--neutral-400);
            cursor: not-allowed;
            transform: none;
        }

        button#classifyButton {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 150px;
            width: 100%;
        }

        /* Style for delete/action buttons in history and tree */
        .action-button {
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 0.1rem 0.3rem; /* Smaller padding */
            font-size: 0.85em; /* Slightly smaller icon */
            line-height: 1;
            margin-left: 0.3rem;
            vertical-align: middle;
        }
        .action-button.delete-button { color: var(--danger); }
        .action-button.delete-button:hover { color: var(--danger-dark); }
        .action-button.rename-icon { color: var(--neutral-500); }
        .action-button.rename-icon:hover { color: var(--primary); }
        .action-button.create-folder-icon { color: var(--warning); } /* New icon style */
        .action-button.create-folder-icon:hover { color: var(--warning-dark); }
        .action-button.save-rename { color: var(--success); }
        .action-button.save-rename:hover { color: var(--success-dark); }
        .action-button.cancel-rename { color: var(--neutral-600); }
        .action-button.cancel-rename:hover { color: var(--neutral-800); }

        /* Container for inline rename controls */
        .rename-controls {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            /* Adjust width carefully if needed, might overlap action buttons */
            max-width: calc(100% - 80px); /* Example adjustment */
            margin-left: 0.5rem;
        }
        .rename-controls input.rename-input {
            flex-grow: 1;
            font-size: 0.9em;
            padding: 0.3rem 0.5rem;
        }
        .rename-controls .action-button {
             margin-left: 0.1rem;
        }

        /* --- Loader --- */
        .loader {
            border: 3px solid rgba(255,255,255,0.3);
            border-top: 3px solid white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            animation: spin 1s linear infinite;
            display: none;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* --- Info Boxes --- */
        .info {
            background-color: var(--info-light);
            color: var(--info-dark);
            border-left: 4px solid var(--primary);
            padding: 1rem;
            border-radius: var(--radius-sm);
            margin-bottom: 1.5rem;
            text-align: left;
            font-size: 0.95rem;
        }
        .info i { /* Ensure icons in info box align */
           vertical-align: middle;
           margin: 0 0.1em;
        }

        /* --- Result Display --- */
        .result-display-area {
            margin-top: 1.5rem;
            padding: 1.5rem;
            background-color: white;
            border-radius: var(--radius);
            border: 1px solid var(--neutral-200);
            text-align: left;
            word-wrap: break-word;
            display: none;
            font-size: 0.95em;
            min-height: 100px;
            box-shadow: var(--shadow-sm);
            transition: all 0.3s ease;
        }

        .result-display-area.error {
            background-color: var(--danger-light);
            color: var(--danger);
            border-left: 4px solid var(--danger);
        }

        .result-display-area strong.title {
            display: block;
            margin-bottom: 0.75rem;
            color: var(--primary);
            font-weight: 600;
            font-size: 1.1rem;
            border-bottom: 1px solid var(--neutral-200);
            padding-bottom: 0.75rem;
        }

        .result-display-area.error strong.title {
            color: var(--danger);
        }

        .result-display-area pre {
            background-color: var(--neutral-50);
            padding: 1rem;
            border-radius: var(--radius-sm);
            border: 1px solid var(--neutral-200);
            font-family: Monaco, Menlo, Consolas, "Liberation Mono", monospace;
            white-space: pre-wrap;
            word-break: break-all;
            font-size: 0.9rem;
            margin: 0;
            color: var(--neutral-800);
            overflow-x: auto;
            max-height: 400px;
            overflow-y: auto;
        }

        .result-display-area.error pre {
            color: var(--danger);
            background-color: transparent;
            border: none;
            padding: 0;
            white-space: pre-wrap;
            font-family: inherit;
            font-size: 1em;
        }

        /* --- History List --- */
        #historyList {
            list-style: none;
            padding: 0;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--neutral-200);
            border-radius: var(--radius);
            margin-bottom: 1rem;
            background-color: white;
        }

        #historyList li {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--neutral-200);
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            transition: background-color 0.2s ease;
            color: var(--neutral-700);
        }

        #historyList li:last-child {
            border-bottom: none;
        }

        #historyList li:hover {
            background-color: var(--neutral-100);
        }

        #historyList li.selected {
            background-color: var(--primary-light);
            color: var(--primary-dark);
            font-weight: 500;
            border-left: 4px solid var(--primary);
        }

        /* Ensure delete button aligns correctly in list */
        #historyList .action-button.delete-button {
            margin-left: auto; /* Push delete button to the right */
            padding-left: 0.5rem; /* Add some space */
        }

        /* --- History Actions --- */
        .history-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            gap: 0.75rem;
        }

        .history-actions button {
            margin-top: 0;
            padding: 0.75rem 1rem;
            font-size: 0.9rem;
            flex-shrink: 0;
        }

        #showAllButton {
            background-color: var(--success);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        #showAllButton:hover {
            background-color: #0d9488;
        }

        #clearHistoryButton {
            background-color: var(--danger);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        #clearHistoryButton:hover {
            background-color: #b91c1c;
        }

        /* --- URL Tree --- */
        #urlTreeContainer {
            font-size: 0.95rem;
            border: 1px solid var(--neutral-200);
            padding: 1.5rem;
            border-radius: var(--radius);
            max-height: 500px;
            overflow: auto;
            background-color: white;
            box-shadow: var(--shadow-sm);
        }

        #urlTreeContainer ul {
            list-style: none;
            padding-left: 1.5rem;
            margin-top: 0.5rem;
        }

        #urlTreeContainer li {
            margin-bottom: 0.5rem;
            position: relative;
        }

        /* Folder toggle icon */
        .toggle-icon {
            cursor: pointer;
            margin-right: 0.5rem;
            width: 1em; /* Ensure consistent width */
            display: inline-block;
            text-align: center;
        }

        #urlTreeContainer li::before {
            content: "";
            position: absolute;
            left: -1rem;
            top: 0.7rem; /* Adjust if needed */
            width: 0.5rem;
            height: 0;
            border-top: 1px solid var(--neutral-300);
        }

        #urlTreeContainer ul > li::after {
            content: "";
            position: absolute;
            left: -1rem;
            top: 0;
            height: 100%;
            border-left: 1px solid var(--neutral-300);
        }

        #urlTreeContainer ul > li:last-child::after {
            height: 0.7rem; /* Adjust vertical line height for last item */
        }

        /* Style for category labels (potential drop targets) */
        #urlTreeContainer .category-label {
            font-weight: 600;
            color: var(--neutral-700);
            display: inline-flex;
            align-items: center;
            margin-bottom: 0.3rem;
            padding: 0.25rem 0.5rem;
            position: relative;
            width: 100%;
            border-radius: var(--radius-sm);
            transition: background-color 0.2s ease, border 0.2s ease;
            border: 1px solid transparent;
        }
        /* Prevent text/icons interfering with drop/click */
        #urlTreeContainer .category-label > .label-text,
        #urlTreeContainer .category-label .folder-icon {
             pointer-events: none;
        }
        #urlTreeContainer .category-label > .label-text {
             margin-right: 5px;
        }
        /* Style for drop zone indication */
        #urlTreeContainer .category-label.drag-over {
            background-color: var(--primary-light);
            border: 1px dashed var(--primary);
        }
        /* Container for action buttons on category label */
        .category-actions {
            margin-left: auto; /* Push actions to the right */
            display: inline-flex;
            align-items: center;
        }

        /* Add folder icon using FA class */
        #urlTreeContainer .category-label .folder-icon {
            margin-right: 0.5rem;
            color: var(--primary);
        }

        /* Style for URL links (draggable items) */
        #urlTreeContainer .url-link {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.25rem 0.5rem;
            border-radius: var(--radius-sm);
            transition: opacity 0.2s ease;
            cursor: grab;
        }
        /* Style for when dragging */
         #urlTreeContainer .url-link.dragging {
            opacity: 0.5;
            cursor: grabbing;
            background-color: var(--neutral-200);
        }
        /* Prevent link click during drag */
        #urlTreeContainer .url-link a {
            pointer-events: none;
        }

        #urlTreeContainer .url-link a {
            color: var(--primary);
            text-decoration: none;
            word-break: break-all;
            font-size: 0.9rem;
            display: inline-flex;
            align-items: center;
            margin-right: 5px;
        }

        #urlTreeContainer .url-link a::before {
            content: "\f0c1"; /* link icon */
            font-family: "Font Awesome 6 Free";
            font-weight: 900;
            margin-right: 0.5rem;
            font-size: 0.8rem;
            color: var(--neutral-500);
        }

        #urlTreeContainer .empty-tree {
            font-style: italic;
            color: var(--neutral-500);
            text-align: center;
            padding: 2rem;
        }

        /* Hidden utility class */
        .hidden {
            display: none !important;
        }

        /* --- Responsive Styles --- */
        @media (max-width: 768px) {
             /* ... same as before ... */
            .main-wrapper {
                border-radius: var(--radius);
            }

            .page-content {
                padding: 1.25rem;
            }
            #urlTreeContainer .category-label > .label-text {
                 max-width: calc(100% - 100px);
                 overflow: hidden;
                 text-overflow: ellipsis;
                 white-space: nowrap;
                 display: inline-block;
            }
            #urlTreeContainer .url-link a {
                 max-width: calc(100% - 40px);
            }
        }

        @media (max-width: 600px) {
             /* ... same as before ... */
            body {
                padding: 10px;
            }

            h1 {
                font-size: 1.5rem;
                padding: 1rem 0;
            }

            .tab-button {
                padding: 0.75rem 0.5rem;
                font-size: 0.85rem;
            }

            .tab-container {
                padding: 0;
            }

            .tab-button i {
                margin-right: 0;
            }

            .tab-button span {
                display: none;
            }

            .history-actions {
                flex-direction: column;
            }

            .history-actions button {
                width: 100%;
            }

            #urlTreeContainer ul {
                padding-left: 1rem;
            }

            .result-display-area pre {
                font-size: 0.8rem;
            }
            .rename-controls {
                width: calc(100% - 20px);
            }
             #urlTreeContainer .category-label > .label-text {
                  max-width: calc(100% - 120px);
             }
             #urlTreeContainer .url-link a {
                  max-width: calc(100% - 50px);
             }
        }
    </style>
</head>
<body>
    <div class="main-wrapper">
        <h1>Web Page Classifier</h1>

        <!-- Tab Navigation -->
        <div class="tab-container">
            <!-- ... tabs ... -->
            <button class="tab-button active" data-target="classifierPage">
                <i class="fas fa-magnifying-glass"></i>
                <span>Classifier</span>
            </button>
            <button class="tab-button" data-target="historyPage">
                <i class="fas fa-clock-rotate-left"></i>
                <span>History</span>
            </button>
            <button class="tab-button" data-target="treePage">
                <i class="fas fa-sitemap"></i>
                <span>URL Tree</span>
            </button>
        </div>

        <!-- Classifier Page Content -->
        <div id="classifierPage" class="page-content active">
             <!-- ... content ... -->
             <div class="info">
                <i class="fas fa-circle-info"></i> Enter a URL. The classification result (JSON) will be displayed below and saved to history using organizational heuristics.
            </div>
            <div class="form-group">
                <label for="pageUrl">Web Page URL:</label>
                <input type="url" id="pageUrl" placeholder="https://example.com/article" required>
            </div>
            <button id="classifyButton">
                <div class="loader" id="loader"></div>
                <span>Classify URL</span>
            </button>
            <div id="classifierResultDisplay" class="result-display-area">
                <strong class="title">API Result (Raw):</strong> <!-- Changed title slightly -->
                <pre></pre>
            </div>
        </div>

        <!-- History Page Content -->
        <div id="historyPage" class="page-content">
            <!-- ... content ... -->
            <h2>Classification History List</h2>
            <ul id="historyList"><li></li></ul>
            <div class="history-actions">
                <button id="showAllButton">
                    <i class="fas fa-list"></i>
                    <span>Show All URLs & Classifications</span>
                </button>
                <button id="clearHistoryButton">
                    <i class="fas fa-trash-can"></i>
                    <span>Clear History</span>
                </button>
            </div>
            <div id="historyResultDisplay" class="result-display-area">
                <strong class="title">Selected / All History:</strong>
                <pre></pre>
            </div>
        </div>

        <!-- Tree Page Content -->
        <div id="treePage" class="page-content">
            <!-- ... content ... -->
            <h2>URL Classification Tree</h2>
            <div class="info">
                 <i class="fas fa-circle-info"></i> Drag & drop a URL (<i class="fas fa-link"></i>) onto a category (<i class="fas fa-folder"></i>) to move.
                 Click <i class="fas fa-chevron-down"></i>/<i class="fas fa-chevron-right"></i> to fold/unfold.
                 Click <i class="fas fa-pencil-alt"></i> to rename.
                 Click <i class="fas fa-folder-plus"></i> to add a subfolder.
                 Click <i class="fas fa-trash-alt"></i> on a URL to delete.
            </div>
            <div id="urlTreeContainer">
                <!-- Tree will be rendered here by JavaScript -->
            </div>
        </div>

    </div> <!-- End main-wrapper -->

    <script>
        // --- Configuration ---
        const NETLIFY_FUNCTION_ENDPOINT = '/.netlify/functions/classify-url';
        const LOCAL_STORAGE_KEY = 'urlClassificationHistory';
        const DRAG_DATA_TYPE = 'text/plain';
        const DUMMY_ITEM_PREFIX = 'placeholder://dummy_';
        const MAX_ITEMS_PER_CATEGORY = 8; // Threshold for auto-subcategorization
        const MIN_KEYWORD_LENGTH = 4; // Minimum length for a keyword to be considered for subcategorization
        // Simple stop words list
        const STOP_WORDS = new Set(['the', 'a', 'an', 'and', 'or', 'but', 'is', 'are', 'was', 'were', 'in', 'on', 'at', 'to', 'for', 'with', 'of', 'it', 'this', 'that', 'from', 'by', 'as', 'new', 'news', 'web', 'site', 'page', 'com', 'org', 'net', 'html', 'http', 'https']);

        // --- DOM Elements ---
        // ... (no changes)
        const classifyButton = document.getElementById('classifyButton');
        const urlInput = document.getElementById('pageUrl');
        const loader = document.getElementById('loader');
        const buttonText = classifyButton.querySelector('span');
        const classifierResultDisplay = document.getElementById('classifierResultDisplay');
        const historyResultDisplay = document.getElementById('historyResultDisplay');
        const historyList = document.getElementById('historyList');
        const clearHistoryButton = document.getElementById('clearHistoryButton');
        const showAllButton = document.getElementById('showAllButton');
        const urlTreeContainer = document.getElementById('urlTreeContainer');
        const tabButtons = document.querySelectorAll('.tab-button');
        const pageContents = document.querySelectorAll('.page-content');

        // --- State ---
        // ... (no changes)
        let classificationHistory = [];
        let draggedElement = null;

        // --- Helper: Generate Unique ID ---
        // ... (no changes)
         function generateId(isDummy = false) {
            const randomPart = Math.random().toString(36).substring(2);
            return isDummy ? DUMMY_ITEM_PREFIX + randomPart : Date.now().toString(36) + randomPart;
        }

        // --- Functions ---

        function showLoading(isLoading) { /* ... no changes ... */
            if (isLoading) {
                classifyButton.disabled = true;
                loader.style.display = 'inline-block';
                buttonText.textContent = 'Classifying...';
                // Keep previous result visible during loading if desired? Or hide:
                // classifierResultDisplay.style.display = 'none';
                classifierResultDisplay.classList.remove('error');
            } else {
                classifyButton.disabled = false;
                loader.style.display = 'none';
                buttonText.textContent = 'Classify URL';
            }
        }

        function displayResultInArea(areaElement, data, isError = false, titlePrefix = 'Result') { /* ... no changes ... */
            areaElement.innerHTML = ''; // Clear previous content
            areaElement.style.display = 'block';
            const title = document.createElement('strong');
            title.classList.add('title');
            const resultOutput = document.createElement('pre');
            if (isError) {
                areaElement.classList.add('error');
                title.textContent = `Error:`;
                resultOutput.textContent = (typeof data === 'string') ? data : JSON.stringify(data, null, 2);
            } else {
                areaElement.classList.remove('error');
                title.textContent = `${titlePrefix}:`;
                resultOutput.textContent = JSON.stringify(data, null, 2);
            }
            areaElement.appendChild(title);
            areaElement.appendChild(resultOutput);
        }

        // Delete an entry from history by id
        function deleteHistoryEntryById(entryId) { /* ... no changes ... */
             const initialLength = classificationHistory.length;
            classificationHistory = classificationHistory.filter(entry => entry.id !== entryId);
            if (classificationHistory.length < initialLength) {
                saveHistory();
                renderHistoryList();
                const treeData = buildUrlTree(classificationHistory);
                renderTree(treeData, urlTreeContainer);
                 historyResultDisplay.style.display = 'none';
                 document.querySelectorAll('#historyList li.selected').forEach(el => el.classList.remove('selected'));
                 console.log(`Deleted history entry ${entryId}`);
            } else {
                console.warn(`Attempted to delete non-existent entry ${entryId}`);
            }
        }

        // --- History List Rendering and Management ---

        function renderHistoryList() { /* ... no changes ... */
            historyList.innerHTML = '';
            const nonDummyHistory = classificationHistory.filter(item => !item.id.startsWith(DUMMY_ITEM_PREFIX)); // Exclude dummies

            if (nonDummyHistory.length === 0) {
                const emptyLi = document.createElement('li');
                emptyLi.textContent = "No history yet.";
                emptyLi.style.fontStyle = "italic";
                emptyLi.style.color = "var(--neutral-500)";
                emptyLi.style.textAlign = "center";
                emptyLi.style.cursor = "default";
                historyList.appendChild(emptyLi);
                return;
            }

            nonDummyHistory.forEach((item) => {
                const li = document.createElement('li');
                const textSpan = document.createElement('span');
                textSpan.textContent = item.url;
                textSpan.style.overflow = 'hidden';
                textSpan.style.textOverflow = 'ellipsis';
                textSpan.style.whiteSpace = 'nowrap';
                textSpan.title = item.url;
                li.appendChild(textSpan);

                li.dataset.id = item.id;

                const delBtn = document.createElement('button');
                delBtn.classList.add('action-button', 'delete-button');
                delBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
                delBtn.title = "Delete this entry";
                delBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteHistoryEntryById(item.id);
                });
                li.appendChild(delBtn);

                li.addEventListener('click', () => {
                    document.querySelectorAll('#historyList li.selected').forEach(el => el.classList.remove('selected'));
                    li.classList.add('selected');
                    if (item.classification) {
                        displayResultInArea(historyResultDisplay, item.classification, false, `Selected: ${item.url}`);
                    } else {
                        displayResultInArea(historyResultDisplay, "Classification data missing for this entry.", true, `Selected: ${item.url}`);
                    }
                });
                historyList.appendChild(li);
            });
        }
        function loadHistory() { /* ... no changes ... */
             try {
                const storedHistory = localStorage.getItem(LOCAL_STORAGE_KEY);
                classificationHistory = storedHistory ? JSON.parse(storedHistory) : [];
                 if (!Array.isArray(classificationHistory)) {
                     console.warn("Stored history was not an array, resetting.");
                     classificationHistory = [];
                     localStorage.removeItem(LOCAL_STORAGE_KEY);
                 }
            } catch (error) {
                console.error("Error loading/parsing history:", error);
                classificationHistory = [];
            }
            renderHistoryList();
            const treeData = buildUrlTree(classificationHistory);
            renderTree(treeData, urlTreeContainer);
        }
        function saveHistory() { /* ... no changes ... */
             try {
                const validHistory = classificationHistory.filter(item => item && item.id);
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(validHistory));
                classificationHistory = validHistory;
            } catch (error) {
                console.error("Error saving history:", error);
                displayResultInArea(classifierResultDisplay, "Could not save history (Storage might be full).", true);
            }
        }

        // --- MODIFIED: Add History Entry Orchestration ---
        function addHistoryEntry(url, rawClassificationData) {
            if (!rawClassificationData || !rawClassificationData.classification) {
                console.error("Invalid classification data received, cannot add to history.", rawClassificationData);
                return;
            }

            // Deep clone the raw data to avoid modifying the object displayed in the "API Result" area
            const classificationData = JSON.parse(JSON.stringify(rawClassificationData));
            const proposedClassification = classificationData.classification; // The inner object

            // 1. Determine the optimal path (reuse existing or extend)
            const optimalPath = determineOptimalPath(proposedClassification, classificationHistory);

            // Update the working classification data with the chosen path
            proposedClassification.url_type = optimalPath.urlType;
            proposedClassification.content_format = optimalPath.format;
            proposedClassification.content_type_hierarchy = [...optimalPath.hierarchy]; // Use a copy

            // 2. Check for subcategorization based on width
            const newItemKeywords = proposedClassification.keywords || [];
            const finalHierarchy = checkAndSubcategorizeIfNeeded(optimalPath, classificationHistory, newItemKeywords);

            // Update the hierarchy one last time if subcategorization occurred
            proposedClassification.content_type_hierarchy = finalHierarchy;

            // 3. Create and add the new entry
            const newEntry = {
                id: generateId(),
                url: url,
                classification: classificationData // Store the whole processed structure
            };

            classificationHistory.unshift(newEntry); // Add to beginning
            console.log(`Added entry ${newEntry.id} with final path: [${optimalPath.urlType}/${optimalPath.format}]/[${finalHierarchy.join('/')}]`);

            // 4. Save and re-render
            saveHistory(); // Includes saving modifications made during subcategorization
            renderHistoryList();
            const treeData = buildUrlTree(classificationHistory);
            renderTree(treeData, urlTreeContainer);
        }


        function showAllHistory() { /* ... no changes ... */
            const nonDummyHistory = classificationHistory.filter(item => !item.id.startsWith(DUMMY_ITEM_PREFIX));
            if (nonDummyHistory.length === 0) {
                displayResultInArea(historyResultDisplay, "History is empty.", true, "Full History");
            } else {
                 const displayHistory = nonDummyHistory.map(({ id, ...rest }) => rest);
                 displayResultInArea(historyResultDisplay, displayHistory, false, "All Stored Classifications");
            }
            document.querySelectorAll('#historyList li.selected').forEach(el => el.classList.remove('selected'));
        }
        function clearHistory() { /* ... no changes ... */
            if (confirm("Are you sure you want to clear the entire classification history? This cannot be undone.")) {
                classificationHistory = [];
                saveHistory();
                renderHistoryList();
                historyResultDisplay.style.display = 'none';
                urlTreeContainer.innerHTML = '<div class="empty-tree">History cleared.</div>';
            }
        }


        // --- Tree Building and Rendering Logic ---
        // ... (buildUrlTree and renderTreeNode remain exactly the same as the previous version) ...
        // Helper to safely get nested properties
        const get = (obj, path, defaultValue = undefined) => { /* ... no changes ... */
            const travel = (regexp) =>
                String.prototype.split
                .call(path, regexp)
                .filter(Boolean)
                .reduce((res, key) => (res !== null && res !== undefined ? res[key] : res), obj);
            const result = travel(/[,[\]]+?/) || travel(/[,[\].]+?/);
            return result === undefined || result === obj ? defaultValue : result;
        };

        function buildUrlTree(history) { /* ... no changes needed ... */
            const tree = {}; // Root of the tree

            history.forEach(item => {
                if (!item || !item.id || !item.classification) return;
                const classification = get(item, 'classification.classification');
                if (!classification) return;

                const urlType = classification.url_type || 'Unknown Type';
                const format = classification.content_format || 'Unknown Format';
                const hierarchy = Array.isArray(classification.content_type_hierarchy) && classification.content_type_hierarchy.length > 0
                                  ? classification.content_type_hierarchy
                                  : ['Unknown Category'];

                let currentLevel = tree;
                let parentMetaHierarchy = [];

                // Level 1: URL Type
                 const metaUrlType = { urlType: urlType, format: null, hierarchy: [urlType] };
                 if (!currentLevel[urlType]) currentLevel[urlType] = { _meta: metaUrlType };
                 // Ensure meta exists even if node already present
                 else if (!currentLevel[urlType]._meta) currentLevel[urlType]._meta = metaUrlType;
                 parentMetaHierarchy = currentLevel[urlType]._meta.hierarchy;
                 currentLevel = currentLevel[urlType];


                // Level 2: Content Format (Conditional based on 'HTML')
                let formatKey = format;
                let actualFormatForMeta = format;
                let formatSkipped = false;
                if (format.trim().toLowerCase() !== 'html') {
                    const metaFormat = { urlType: urlType, format: actualFormatForMeta, hierarchy: [...parentMetaHierarchy, formatKey] };
                    if (!currentLevel[formatKey]) currentLevel[formatKey] = { _meta: metaFormat };
                    else if (!currentLevel[formatKey]._meta) currentLevel[formatKey]._meta = metaFormat;
                    parentMetaHierarchy = currentLevel[formatKey]._meta.hierarchy;
                    currentLevel = currentLevel[formatKey];
                } else {
                    actualFormatForMeta = 'HTML';
                    formatSkipped = true;
                }

                // Levels 3+: Content Type Hierarchy
                hierarchy.forEach((category, index) => {
                    const isLastLevel = index === hierarchy.length - 1;
                    const currentMetaHierarchy = formatSkipped
                        ? [urlType, ...hierarchy.slice(0, index + 1)]
                        : [urlType, formatKey, ...hierarchy.slice(0, index + 1)];

                    const metaHierarchy = {
                         urlType: urlType,
                         format: actualFormatForMeta,
                         hierarchy: currentMetaHierarchy
                     };

                     if (!currentLevel[category]) {
                         currentLevel[category] = { _meta: metaHierarchy };
                         // Initialize _items only if it's the last level *and* we are adding a real item
                         if (isLastLevel && !item.id.startsWith(DUMMY_ITEM_PREFIX)) {
                            currentLevel[category]._items = [];
                         }
                     } else if (!currentLevel[category]._meta) {
                          // Ensure meta exists if node was already there
                          currentLevel[category]._meta = metaHierarchy;
                     }


                     if (isLastLevel && !item.id.startsWith(DUMMY_ITEM_PREFIX)) {
                          if (!currentLevel[category]._items) { // Ensure _items exists
                              currentLevel[category]._items = [];
                          }
                          if (!currentLevel[category]._items.some(entry => entry.id === item.id)) {
                              currentLevel[category]._items.push({ id: item.id, url: item.url });
                          }
                     }

                     if (!isLastLevel) {
                        currentLevel = currentLevel[category];
                     }
                });
            });
            return tree;
        }

        function renderTree(treeData, containerElement) { /* ... no changes needed ... */
             containerElement.innerHTML = '';
            if (Object.keys(treeData).length === 0) {
                containerElement.innerHTML = '<div class="empty-tree">No classification data available to build the tree.</div>';
                return;
            }
            const rootUl = document.createElement('ul');
            containerElement.appendChild(rootUl);
            renderTreeNode(treeData, rootUl);
        }

        function renderTreeNode(node, parentUl) { /* ... no changes needed ... */
             const categories = Object.keys(node).filter(key => key !== '_meta' && key !== '_items').sort();

            categories.forEach(category => {
                const li = document.createElement('li');
                const nodeValue = node[category];
                const meta = nodeValue._meta;
                const items = nodeValue._items || [];

                const isFolder = Object.keys(nodeValue).some(k => k !== '_meta' && k !== '_items');
                const hasRealItems = items.some(item => !item.id.startsWith(DUMMY_ITEM_PREFIX));

                 if (!meta) {
                    console.warn("Node missing _meta data:", category, nodeValue);
                    return;
                 }

                const header = document.createElement('div');
                header.classList.add('category-label');
                header.dataset.targetUrlType = meta.urlType;
                header.dataset.targetFormat = meta.format === null ? 'HTML' : meta.format;
                header.dataset.targetHierarchy = JSON.stringify(meta.hierarchy);

                const toggleIcon = document.createElement('i');
                if (isFolder || items.length > 0) {
                   toggleIcon.classList.add('toggle-icon', 'fas', 'fa-chevron-down');
                } else {
                   toggleIcon.classList.add('toggle-icon', 'fas', 'fa-minus');
                   toggleIcon.style.opacity = '0.3';
                   toggleIcon.style.cursor = 'default';
                }

                const iconSpan = document.createElement('i');
                iconSpan.classList.add('fas', 'fa-folder', 'folder-icon');
                const labelSpan = document.createElement('span');
                labelSpan.classList.add('label-text');
                labelSpan.textContent = category;

                header.appendChild(toggleIcon);
                header.appendChild(iconSpan);
                header.appendChild(labelSpan);

                 const actionsContainer = document.createElement('div');
                 actionsContainer.classList.add('category-actions');

                 const renameIcon = document.createElement('button');
                 renameIcon.classList.add('action-button', 'rename-icon');
                 renameIcon.innerHTML = '<i class="fas fa-pencil-alt"></i>';
                 renameIcon.title = `Rename category "${category}"`;
                 renameIcon.dataset.categoryName = category;
                 renameIcon.dataset.fullHierarchyPath = JSON.stringify(meta.hierarchy);
                 actionsContainer.appendChild(renameIcon);

                 const createFolderIcon = document.createElement('button');
                 createFolderIcon.classList.add('action-button', 'create-folder-icon');
                 createFolderIcon.innerHTML = '<i class="fas fa-folder-plus"></i>';
                 createFolderIcon.title = `Create subfolder in "${category}"`;
                 createFolderIcon.dataset.parentUrlType = meta.urlType;
                 createFolderIcon.dataset.parentFormat = meta.format === null ? 'HTML' : meta.format;
                 createFolderIcon.dataset.parentHierarchy = JSON.stringify(meta.hierarchy);
                 actionsContainer.appendChild(createFolderIcon);

                 header.appendChild(actionsContainer);

                li.appendChild(header);

                let nestedUl = null;
                if (isFolder || items.length > 0) {
                    nestedUl = document.createElement('ul');

                    if (isFolder) {
                        renderTreeNode(nodeValue, nestedUl);
                    }

                    items.filter(item => !item.id.startsWith(DUMMY_ITEM_PREFIX))
                         .sort((a, b) => a.url.localeCompare(b.url))
                         .forEach(entry => {
                            const urlLi = document.createElement('li');
                            urlLi.classList.add('url-link');
                            urlLi.draggable = true;
                            urlLi.dataset.entryId = entry.id;

                            const link = document.createElement('a');
                            link.href = entry.url;
                            link.textContent = entry.url;
                            link.title = entry.url;
                            link.target = '_blank';
                            link.rel = 'noopener noreferrer';
                            urlLi.appendChild(link);

                            const deleteBtn = document.createElement('button');
                            deleteBtn.classList.add('action-button', 'delete-button');
                            deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
                            deleteBtn.title = "Delete this URL entry";
                            deleteBtn.addEventListener('click', (e) => {
                                e.stopPropagation();
                                deleteHistoryEntryById(entry.id);
                            });
                            urlLi.appendChild(deleteBtn);
                            nestedUl.appendChild(urlLi);
                        });
                     li.appendChild(nestedUl);

                     if (toggleIcon.classList.contains('toggle-icon')) {
                         toggleIcon.addEventListener('click', (e) => {
                             e.stopPropagation();
                             const isHidden = nestedUl.style.display === 'none';
                             nestedUl.style.display = isHidden ? 'block' : 'none';
                             toggleIcon.classList.replace(
                                 isHidden ? 'fa-chevron-right' : 'fa-chevron-down',
                                 isHidden ? 'fa-chevron-down' : 'fa-chevron-right'
                             );
                         });
                     }
                 }
                 parentUl.appendChild(li);
            });
        }


        // --- Rename, Drag/Drop, Create Folder Logic ---
        // ... (showRenameInput, handleRenameSave, handleRenameCancel remain the same) ...
         function showRenameInput(renameIcon) { /* ... no changes ... */
             const headerDiv = renameIcon.closest('.category-label');
            const labelSpan = headerDiv.querySelector('.label-text');
            const actionsContainer = headerDiv.querySelector('.category-actions');
            const oldName = renameIcon.dataset.categoryName;

            if (headerDiv.querySelector('.rename-controls')) return;

            labelSpan.classList.add('hidden');
            if (actionsContainer) actionsContainer.classList.add('hidden');

            const input = document.createElement('input');
            input.type = 'text';
            input.value = oldName;
            input.classList.add('rename-input');
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') { handleRenameSave(input); }
                else if (e.key === 'Escape') { handleRenameCancel(input); }
            });

            const saveBtn = document.createElement('button');
            saveBtn.classList.add('action-button', 'save-rename');
            saveBtn.innerHTML = '<i class="fas fa-check"></i>';
            saveBtn.title = 'Save new name';
            saveBtn.addEventListener('click', () => handleRenameSave(input));

            const cancelBtn = document.createElement('button');
            cancelBtn.classList.add('action-button', 'cancel-rename');
            cancelBtn.innerHTML = '<i class="fas fa-times"></i>';
            cancelBtn.title = 'Cancel rename';
            cancelBtn.addEventListener('click', () => handleRenameCancel(input));

            const controls = document.createElement('div');
            controls.classList.add('rename-controls');
            controls.appendChild(input);
            controls.appendChild(saveBtn);
            controls.appendChild(cancelBtn);

            headerDiv.insertBefore(controls, labelSpan);
            input.focus();
            input.select();
         }
         function handleRenameSave(inputElement) { /* ... no changes ... */
             const controlsDiv = inputElement.closest('.rename-controls');
            if (!controlsDiv) return;
            const headerDiv = controlsDiv.closest('.category-label');
            const actionsContainer = headerDiv.querySelector('.category-actions');
            const renameIcon = actionsContainer?.querySelector('.rename-icon');
             if (!renameIcon) {
                 console.error("Could not find original rename icon data.");
                 handleRenameCancel(inputElement);
                 return;
             }

            const oldName = renameIcon.dataset.categoryName;
            const fullHierarchyPathString = renameIcon.dataset.fullHierarchyPath;
            const newName = inputElement.value.trim();

            if (newName && newName !== oldName) {
                 try {
                     const fullHierarchyPath = JSON.parse(fullHierarchyPathString);
                     if (renameCategoryInData(fullHierarchyPath, oldName, newName)) {
                        console.log(`Renamed category based on path [${fullHierarchyPath.join('/')}] to "${newName}"`);
                        const treeData = buildUrlTree(classificationHistory);
                        renderTree(treeData, urlTreeContainer);
                     } else {
                        console.error("Rename function reported no changes made.");
                        handleRenameCancel(inputElement);
                     }
                 } catch (e) {
                     console.error("Error parsing path or renaming:", e);
                     handleRenameCancel(inputElement);
                 }
            } else {
                handleRenameCancel(inputElement);
            }
         }
         function handleRenameCancel(inputElement) { /* ... no changes ... */
             const controlsDiv = inputElement.closest('.rename-controls');
             if (!controlsDiv) return;
            const headerDiv = controlsDiv.closest('.category-label');
            const labelSpan = headerDiv.querySelector('.label-text');
            const actionsContainer = headerDiv.querySelector('.category-actions');

            controlsDiv.remove();
            labelSpan.classList.remove('hidden');
             if (actionsContainer) actionsContainer.classList.remove('hidden');
         }
        function renameCategoryInData(fullHierarchyPath, oldName, newName) { /* ... no changes needed from previous version... */
             if (!fullHierarchyPath || fullHierarchyPath.length === 0 || !oldName || !newName || oldName === newName) {
                 console.warn("Rename aborted: Invalid parameters.");
                 return false;
             }

             let changesMade = false;
             const targetUrlType = fullHierarchyPath[0];
             const hierarchyRenameIndex = fullHierarchyPath.length - 2; // Index relative to start of item's hierarchy array


             classificationHistory.forEach(item => {
                 if (item.id.startsWith(DUMMY_ITEM_PREFIX)) return;
                 const classification = get(item, 'classification.classification');
                 if (!classification) return;

                 const itemUrlType = classification.url_type || 'Unknown Type';
                 const itemHierarchy = Array.isArray(classification.content_type_hierarchy)
                                       ? [...classification.content_type_hierarchy] // Copy
                                       : ['Unknown Category'];

                 if (itemUrlType === targetUrlType) {
                     if (itemHierarchy.length > hierarchyRenameIndex) {
                         if (itemHierarchy[hierarchyRenameIndex] === oldName) {
                             let prefixMatch = true;
                             for (let i = 0; i < hierarchyRenameIndex; i++) {
                                 // Check item hierarchy part against the corresponding part in the *full* path (offset by 1)
                                 if (itemHierarchy[i] !== fullHierarchyPath[i + 1]) {
                                     prefixMatch = false;
                                     break;
                                 }
                             }
                             if (prefixMatch) {
                                 itemHierarchy[hierarchyRenameIndex] = newName;
                                 // IMPORTANT: Update the actual object in classificationHistory
                                 item.classification.classification.content_type_hierarchy = itemHierarchy;
                                 changesMade = true;
                             }
                         }
                     }
                 }
             });

             if (changesMade) {
                 // No need to save here, saveHistory() is called after addHistoryEntry finishes
             } else {
                  console.warn("Rename function executed, but no matching history entries found/modified for path:", fullHierarchyPath);
             }
             return changesMade; // Return status
        }

        function moveHistoryEntry(entryId, targetUrlType, targetFormat, targetHierarchyArray) { /* ... no changes ... */
             if (!Array.isArray(targetHierarchyArray)) {
                console.error("Cannot move entry: targetHierarchy is not an array.", targetHierarchyArray);
                return false;
            }

             const entryIndex = classificationHistory.findIndex(item => item.id === entryId);
             if (entryIndex === -1) {
                 console.error(`Cannot move entry: ID ${entryId} not found.`);
                 return false;
             }

             const entry = classificationHistory[entryIndex];
             let classification = get(entry, 'classification.classification'); // Use let

             if (!classification) {
                 console.warn(`Creating classification structure for moved entry: ID ${entryId}.`);
                  if (!entry.classification) entry.classification = {};
                  if (!entry.classification.classification) entry.classification.classification = {};
                  classification = entry.classification.classification; // Reassign
             }

             let actualTargetHierarchy = [];
             // Find the starting index of the actual hierarchy parts within the meta path
             let hierarchyStartIndex = 1; // Start after urlType
             if (targetHierarchyArray.length > 1 && targetHierarchyArray[1] === targetFormat && targetFormat !== targetUrlType) {
                hierarchyStartIndex = 2; // Skip format as well
             }
             actualTargetHierarchy = targetHierarchyArray.slice(hierarchyStartIndex);


             classification.url_type = targetUrlType;
             classification.content_format = targetFormat;
             classification.content_type_hierarchy = actualTargetHierarchy;

             console.log(`Moved entry ${entryId} to [${targetUrlType}/${targetFormat}]/[${actualTargetHierarchy.join('/')}]`);
             // No save needed here, will be saved after addHistoryEntry finishes or by caller if used elsewhere
             return true;
        }

        function handleCreateFolder(createIcon) { /* ... no changes ... */
             const parentUrlType = createIcon.dataset.parentUrlType;
            const parentFormat = createIcon.dataset.parentFormat;
            const parentHierarchyString = createIcon.dataset.parentHierarchy;

            if (!parentUrlType || !parentFormat || !parentHierarchyString) {
                 console.error("Cannot create folder: Missing parent data on icon.");
                 return;
            }

             const newFolderName = prompt("Enter name for the new subfolder:");

             if (newFolderName && newFolderName.trim()) {
                 const trimmedName = newFolderName.trim();
                 try {
                     const parentHierarchyMetaPath = JSON.parse(parentHierarchyString);

                     let parentHierarchyParts = [];
                     let hierarchyStartIndex = 1;
                     if (parentHierarchyMetaPath.length > 1 && parentHierarchyMetaPath[1] === parentFormat && parentFormat !== parentUrlType) {
                         hierarchyStartIndex = 2;
                     }
                     parentHierarchyParts = parentHierarchyMetaPath.slice(hierarchyStartIndex);


                     const newHierarchy = [...parentHierarchyParts, trimmedName];

                     const dummyEntry = {
                         id: generateId(true),
                         url: `${DUMMY_ITEM_PREFIX}${trimmedName}/${generateId()}`,
                         classification: {
                             classification: {
                                 url_type: parentUrlType,
                                 content_format: parentFormat,
                                 content_type_hierarchy: newHierarchy,
                                 primary_language: "Undetermined",
                                 keywords: [],
                                 confidence: "Low"
                             }
                         }
                     };

                     console.log("Creating dummy entry:", dummyEntry);
                     classificationHistory.push(dummyEntry);
                     saveHistory();

                     const treeData = buildUrlTree(classificationHistory);
                     renderTree(treeData, urlTreeContainer);

                 } catch (e) {
                     console.error("Error parsing parent hierarchy or creating folder:", e);
                     alert("Failed to create folder due to an internal error.");
                 }
             } else if (newFolderName !== null) {
                  alert("Folder name cannot be empty.");
             }
        }


         // --- NEW: Path Optimization & Subcategorization Logic ---

         // Helper: Compare two hierarchy arrays, return length of common prefix
         function getCommonPrefixLength(h1, h2) {
             let len = 0;
             const maxLen = Math.min(h1.length, h2.length);
             for (let i = 0; i < maxLen; i++) {
                 if (h1[i] === h2[i]) {
                     len++;
                 } else {
                     break;
                 }
             }
             return len;
         }

         // Determines the best path to store the new item under
         function determineOptimalPath(proposedClassification, history) {
             const pUrlType = proposedClassification.url_type || 'Unknown Type';
             const pFormat = proposedClassification.content_format || 'Unknown Format';
             // Ensure hierarchy is always an array, handle potential null/undefined
             const pHierarchy = Array.isArray(proposedClassification.content_type_hierarchy) ? proposedClassification.content_type_hierarchy : ['Unknown Category'];

             let bestMatch = { urlType: pUrlType, format: pFormat, hierarchy: [...pHierarchy], score: -1 };
             let perfectMatchFound = false;

             const nonDummyHistory = history.filter(item => !item.id.startsWith(DUMMY_ITEM_PREFIX));

             for (const item of nonDummyHistory) {
                 const existingClassification = get(item, 'classification.classification');
                 if (!existingClassification) continue;

                 const eUrlType = existingClassification.url_type || 'Unknown Type';
                 const eFormat = existingClassification.content_format || 'Unknown Format';
                 const eHierarchy = Array.isArray(existingClassification.content_type_hierarchy) ? existingClassification.content_type_hierarchy : ['Unknown Category'];

                 let currentScore = 0;
                 let commonPrefixLen = 0;

                 if (eUrlType === pUrlType) {
                     currentScore += 1; // Base score for matching type
                     if (eFormat === pFormat) {
                         currentScore += 1; // Bonus for matching format
                         commonPrefixLen = getCommonPrefixLength(eHierarchy, pHierarchy);
                         currentScore += commonPrefixLen; // Add length of common hierarchy
                     }
                     // else: Only URL type matched, hierarchy doesn't matter for scoring here

                     // Check for perfect match
                     if (eFormat === pFormat && eHierarchy.length === pHierarchy.length && commonPrefixLen === pHierarchy.length) {
                         console.log("Found perfect path match:", { urlType: eUrlType, format: eFormat, hierarchy: eHierarchy });
                         perfectMatchFound = true;
                         bestMatch = { urlType: eUrlType, format: eFormat, hierarchy: [...eHierarchy], score: Infinity }; // Ensure perfect match wins
                         break; // No need to check further
                     }

                     // Update best partial match if current score is higher
                     if (currentScore > bestMatch.score) {
                         bestMatch = {
                             urlType: eUrlType,
                             format: eFormat,
                             // Store the *existing* hierarchy that gave the best score
                             hierarchy: [...eHierarchy],
                             score: currentScore,
                             // Also store the common prefix length with the *proposed* hierarchy for later use
                             commonPrefixLen: commonPrefixLen
                         };
                     }
                 }
             } // End history loop

             // --- Decide final path ---
             if (perfectMatchFound) {
                 return { urlType: bestMatch.urlType, format: bestMatch.format, hierarchy: bestMatch.hierarchy };
             } else if (bestMatch.score >= 2) { // Require at least type+format or type+some_hierarchy match
                 // Construct path: common prefix from best match + remaining from proposed
                 const commonPrefix = bestMatch.hierarchy.slice(0, bestMatch.commonPrefixLen);
                 const remainingProposed = pHierarchy.slice(bestMatch.commonPrefixLen);
                 const finalHierarchy = [...commonPrefix, ...remainingProposed];
                 console.log("Using partial match. Common:", commonPrefix, "Remaining proposed:", remainingProposed);
                 // Ensure format matches the common prefix part
                 const finalFormat = bestMatch.format;
                 return { urlType: bestMatch.urlType, format: finalFormat, hierarchy: finalHierarchy };
             } else {
                 // No good match, use original proposed path
                 console.log("No suitable existing path found, using proposed path.");
                 return { urlType: pUrlType, format: pFormat, hierarchy: pHierarchy };
             }
         }


         // Checks if subcategorization is needed and performs it by modifying history directly
         // Returns the potentially updated hierarchy for the *new* item being added.
         function checkAndSubcategorizeIfNeeded(targetPath, history, newItemKeywords) {
             const { urlType, format, hierarchy } = targetPath;
             let finalHierarchy = [...hierarchy]; // Start with the target hierarchy

             // Find existing items matching the target path *exactly*
             const matchingItemsIndices = []; // Store indices for direct modification
             const matchingItemsKeywords = [];

             history.forEach((item, index) => {
                  // Skip dummies and the item being added (if it somehow got into history early)
                  if (item.id.startsWith(DUMMY_ITEM_PREFIX)) return;

                 const itemClass = get(item, 'classification.classification');
                 if (itemClass &&
                     (itemClass.url_type || 'Unknown Type') === urlType &&
                     (itemClass.content_format || 'Unknown Format') === format &&
                     Array.isArray(itemClass.content_type_hierarchy) &&
                     itemClass.content_type_hierarchy.length === hierarchy.length &&
                     itemClass.content_type_hierarchy.every((h, i) => h === hierarchy[i]))
                 {
                     matchingItemsIndices.push(index);
                     matchingItemsKeywords.push(...(itemClass.keywords || []));
                 }
             });

             const currentCount = matchingItemsIndices.length;
             const totalCount = currentCount + 1; // Including the new item

             console.log(`Checking subcategorization for path [${urlType}/${format}]/[${hierarchy.join('/')}]: ${currentCount} existing + 1 new = ${totalCount}. Threshold: ${MAX_ITEMS_PER_CATEGORY}`);

             if (totalCount >= MAX_ITEMS_PER_CATEGORY) {
                 console.log("Threshold met, attempting subcategorization...");
                 const allKeywords = [...matchingItemsKeywords, ...newItemKeywords];
                 const keywordCounts = {};

                 // Count keyword frequencies, filter stop words, normalize
                 allKeywords.forEach(kw => {
                     if (typeof kw === 'string') {
                        const cleanedKw = kw.trim().toLowerCase();
                        if (cleanedKw.length >= MIN_KEYWORD_LENGTH && !STOP_WORDS.has(cleanedKw)) {
                            keywordCounts[cleanedKw] = (keywordCounts[cleanedKw] || 0) + 1;
                        }
                     }
                 });

                 // Find the most frequent keyword
                 let bestKeyword = null;
                 let maxCount = 0;
                 for (const [kw, count] of Object.entries(keywordCounts)) {
                     // Prefer keywords that appear more than once, or at least cover a good portion
                     if (count > maxCount && count > 1) { // Stricter: require keyword to be shared
                         maxCount = count;
                         bestKeyword = kw;
                     }
                 }

                 // Fallback: If no keyword repeats, maybe take the most frequent single one? (Less ideal)
                 if (!bestKeyword && Object.keys(keywordCounts).length > 0) {
                     // Find max count even if it's 1
                      for (const [kw, count] of Object.entries(keywordCounts)) {
                         if (count > maxCount) {
                             maxCount = count;
                             bestKeyword = kw;
                         }
                      }
                 }


                 if (bestKeyword) {
                     // Capitalize keyword for folder name
                     const subCategoryName = bestKeyword.charAt(0).toUpperCase() + bestKeyword.slice(1);
                     const newHierarchy = [...hierarchy, subCategoryName];
                     console.log(`Found subcategory keyword: "${subCategoryName}". New hierarchy:`, newHierarchy);

                     // IMPORTANT: Modify existing items IN PLACE in classificationHistory
                     matchingItemsIndices.forEach(index => {
                         const itemToModify = classificationHistory[index];
                         if (itemToModify && itemToModify.classification && itemToModify.classification.classification) {
                             itemToModify.classification.classification.content_type_hierarchy = [...newHierarchy]; // Assign copy
                             console.log(`Updated existing item ${itemToModify.id} to new subcategory.`);
                         }
                     });

                     // Return the new hierarchy for the item being added
                     finalHierarchy = newHierarchy;
                 } else {
                     console.log("Could not determine a suitable keyword for subcategorization.");
                     // Return original hierarchy if no keyword found
                     finalHierarchy = hierarchy;
                 }
             }

             // Return the final hierarchy (either original or with the new subcategory)
             return finalHierarchy;
         }


        // --- Tab Switching Logic ---
        function switchTab(event) { /* ... no changes ... */
             if (draggedElement) {
                 draggedElement.classList.remove('dragging');
                 draggedElement = null;
            }
            document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));

            const targetId = event.currentTarget.dataset.target;
            tabButtons.forEach(button => {
                button.classList.toggle('active', button.dataset.target === targetId);
            });
            pageContents.forEach(page => {
                page.classList.toggle('active', page.id === targetId);
            });
             if (targetId === 'treePage') {
                 const treeData = buildUrlTree(classificationHistory);
                 renderTree(treeData, urlTreeContainer);
             }
        }

        // --- Main Classification Function ---
        async function classifyUrlContent() {
            const pageUrl = urlInput.value.trim();
            if (!pageUrl || !/^https?:\/\/.+/.test(pageUrl)) {
                displayResultInArea(classifierResultDisplay, "Please enter a valid URL (starting with http:// or https://).", true, "Input Error");
                return;
            }
            showLoading(true);
            // Display "pending" message immediately
             displayResultInArea(classifierResultDisplay, `Requesting classification for ${pageUrl}...`, false, "API Request Pending");

            try {
                const response = await fetch(NETLIFY_FUNCTION_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url: pageUrl })
                });
                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error || `Function Error: ${response.status} ${response.statusText}`);
                }

                if (data.classification && typeof data.classification === 'object' && data.classification.classification) {
                    // Display the RAW result first
                    displayResultInArea(classifierResultDisplay, data.classification, false, 'API Result (Raw)');
                    // Now add it using the new logic
                    addHistoryEntry(pageUrl, data.classification);
                } else {
                     console.warn("Received unexpected response format:", data);
                     throw new Error("Received an unexpected response format from the classification service.");
                }
            } catch (error) {
                console.error("Error during classification:", error);
                displayResultInArea(classifierResultDisplay, `Classification failed: ${error.message}`, true, "Classification Error");
            } finally {
                showLoading(false);
            }
        }

        // --- Initialization and Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            loadHistory();

            // Tab switching
            tabButtons.forEach(button => button.addEventListener('click', switchTab));

            // Classifier action
            classifyButton.addEventListener('click', classifyUrlContent);
            urlInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') { event.preventDefault(); classifyUrlContent(); }
            });

            // History actions
            clearHistoryButton.addEventListener('click', clearHistory);
            showAllButton.addEventListener('click', showAllHistory);

            // --- Event delegation for tree actions ---
            urlTreeContainer.addEventListener('click', (event) => { /* ... no changes ... */
                 const renameIcon = event.target.closest('.rename-icon');
                 if (renameIcon) {
                      event.stopPropagation();
                      showRenameInput(renameIcon);
                      return;
                 }
                  const createFolderIcon = event.target.closest('.create-folder-icon');
                  if (createFolderIcon) {
                      event.stopPropagation();
                      handleCreateFolder(createFolderIcon);
                      return;
                  }
            });

            // --- Drag and Drop Event Listeners (Delegated) ---
            urlTreeContainer.addEventListener('dragstart', (event) => { /* ... no changes ... */
                 const targetLi = event.target.closest('li.url-link');
                if (targetLi && targetLi.draggable) {
                    draggedElement = targetLi;
                    const entryId = targetLi.dataset.entryId;
                    event.dataTransfer.setData(DRAG_DATA_TYPE, entryId);
                    event.dataTransfer.effectAllowed = 'move';
                    setTimeout(() => { targetLi.classList.add('dragging'); }, 0);
                }
            });
            urlTreeContainer.addEventListener('dragend', (event) => { /* ... no changes ... */
                 if (draggedElement) {
                     draggedElement.classList.remove('dragging');
                     draggedElement = null;
                     document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
                 }
            });
            urlTreeContainer.addEventListener('dragover', (event) => { /* ... no changes ... */
                const dropTarget = event.target.closest('.category-label');
                if (dropTarget && draggedElement) {
                    event.preventDefault();
                    event.dataTransfer.dropEffect = 'move';
                    dropTarget.classList.add('drag-over');
                }
            });
             urlTreeContainer.addEventListener('dragleave', (event) => { /* ... no changes ... */
                 const dropTarget = event.target.closest('.category-label');
                 if (dropTarget) {
                    dropTarget.classList.remove('drag-over');
                 }
            });
             urlTreeContainer.addEventListener('drop', (event) => { /* ... no changes ... */
                 event.preventDefault();
                const dropTarget = event.target.closest('.category-label');
                 if (dropTarget && draggedElement) {
                     dropTarget.classList.remove('drag-over');

                     const entryId = event.dataTransfer.getData(DRAG_DATA_TYPE);
                     const targetUrlType = dropTarget.dataset.targetUrlType;
                     const targetFormat = dropTarget.dataset.targetFormat;
                     const targetHierarchyString = dropTarget.dataset.targetHierarchy;

                     // console.log(`Drop: Entry ID ${entryId} onto Category Meta [${targetHierarchyString}]`);

                     if (entryId && targetUrlType && targetFormat && targetHierarchyString) {
                          try {
                              const targetHierarchyArray = JSON.parse(targetHierarchyString);

                              if (moveHistoryEntry(entryId, targetUrlType, targetFormat, targetHierarchyArray)) {
                                  // Save history AFTER successful move
                                  saveHistory();
                                  const treeData = buildUrlTree(classificationHistory);
                                  renderTree(treeData, urlTreeContainer);
                              } else {
                                  console.error("Failed to move history entry in data.");
                              }
                          } catch (e) {
                               console.error("Drop failed: Error parsing target hierarchy.", e);
                          }
                     } else {
                         console.error("Drop failed: Missing data from dragged item or drop target.", { entryId, targetUrlType, targetFormat, targetHierarchyString });
                     }
                 }
                 if (draggedElement) {
                     draggedElement.classList.remove('dragging');
                     draggedElement = null;
                 }
             });


            // Ensure default tab content is shown
            document.querySelector('.page-content.active') || document.getElementById('classifierPage').classList.add('active');
            document.querySelector('.tab-button.active') || document.querySelector('.tab-button[data-target="classifierPage"]').classList.add('active');
        });

    </script>
</body>
</html>