<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Page Classifier & History</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* --- Base Styles --- */
        :root {
            --primary: #2563eb;
            --primary-dark: #1d4ed8;
            --primary-light: #dbeafe;
            --success: #10b981;
            --success-dark: #047857;
            --success-light: #d1fae5;
            --danger: #ef4444;
            --danger-dark: #b91c1c;
            --danger-light: #fee2e2;
            --warning: #f59e0b; /* Added for create folder icon */
            --warning-dark: #b45309;
            --neutral-50: #f9fafb;
            --neutral-100: #f3f4f6;
            --neutral-200: #e5e7eb;
            --neutral-300: #d1d5db;
            --neutral-400: #9ca3af;
            --neutral-500: #6b7280;
            --neutral-600: #4b5563;
            --neutral-700: #374151;
            --neutral-800: #1f2937;
            --neutral-900: #111827;
            --info-light: #dbeafe;
            --info-dark: #1e3a8a;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.1);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1);
            --radius-sm: 0.25rem;
            --radius: 0.5rem;
            --radius-md: 0.75rem;
            --radius-lg: 1rem;
        }

        /* ... (rest of CSS styles remain exactly the same as previous version, including action-button etc.) ... */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body { height: 100%; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; background-color: var(--neutral-100); color: var(--neutral-800); padding: 20px; font-size: 16px; }
        .main-wrapper { background-color: #ffffff; padding: 0; border-radius: var(--radius-lg); box-shadow: var(--shadow-lg); width: 100%; max-width: 900px; margin: 0 auto; overflow: hidden; position: relative; transition: box-shadow 0.3s ease; }
        .main-wrapper:hover { box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04); }
        h1 { text-align: center; font-size: 1.8em; padding: 1.5rem 0; color: var(--primary); font-weight: 700; margin-bottom: 0; background-color: white; border-bottom: 1px solid var(--neutral-200); }
        h2 { font-size: 1.3em; margin-bottom: 1rem; text-align: left; color: var(--neutral-800); font-weight: 600; }
        .tab-container { display: flex; background-color: white; border-bottom: 1px solid var(--neutral-200); padding: 0 1rem; }
        .tab-button { padding: 1rem 1.25rem; cursor: pointer; border: none; background-color: transparent; font-size: 1rem; font-weight: 500; color: var(--neutral-600); transition: all 0.2s ease; border-bottom: 3px solid transparent; position: relative; display: flex; align-items: center; gap: 8px; }
        .tab-button:hover { color: var(--primary); background-color: var(--neutral-50); }
        .tab-button.active { color: var(--primary); border-bottom: 3px solid var(--primary); }
        .tab-button.active::after { content: ""; position: absolute; bottom: -3px; left: 0; right: 0; height: 3px; background-color: var(--primary); border-radius: 3px 3px 0 0; }
        .tab-button i { font-size: 0.9rem; }
        .page-content { display: none; padding: 2rem; animation: fadeIn 0.3s ease; }
        .page-content.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
        .form-group { margin-bottom: 1.5rem; text-align: left; }
        label { display: block; margin-bottom: 0.5rem; font-weight: 500; color: var(--neutral-700); font-size: 0.95rem; }
        input[type="url"], input[type="text"].rename-input { width: 100%; padding: 0.75rem 1rem; border: 1px solid var(--neutral-300); border-radius: var(--radius); font-size: 1rem; font-family: inherit; transition: all 0.2s ease; background-color: white; }
        input[type="url"]:focus, input[type="text"].rename-input:focus { outline: none; border-color: var(--primary); box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.15); }
        input[type="url"]::placeholder { color: var(--neutral-400); }
        button { background-color: var(--primary); color: white; border: none; padding: 0.75rem 1.25rem; border-radius: var(--radius); font-size: 1rem; font-weight: 500; cursor: pointer; transition: all 0.2s ease; display: inline-flex; align-items: center; gap: 0.5rem; }
        button:hover { background-color: var(--primary-dark); transform: translateY(-1px); }
        button:active { transform: translateY(0); }
        button:disabled { background-color: var(--neutral-400); cursor: not-allowed; transform: none; }
        button#classifyButton { display: inline-flex; align-items: center; justify-content: center; min-width: 150px; width: 100%; }
        .action-button { background: transparent; border: none; cursor: pointer; padding: 0.1rem 0.3rem; font-size: 0.85em; line-height: 1; margin-left: 0.3rem; vertical-align: middle; }
        .action-button.delete-button { color: var(--danger); }
        .action-button.delete-button:hover { color: var(--danger-dark); }
        .action-button.delete-folder-icon { color: var(--danger); } /* Same color for folder delete */
        .action-button.delete-folder-icon:hover { color: var(--danger-dark); }
        .action-button.rename-icon { color: var(--neutral-500); }
        .action-button.rename-icon:hover { color: var(--primary); }
        .action-button.create-folder-icon { color: var(--warning); }
        .action-button.create-folder-icon:hover { color: var(--warning-dark); }
        .action-button.save-rename { color: var(--success); }
        .action-button.save-rename:hover { color: var(--success-dark); }
        .action-button.cancel-rename { color: var(--neutral-600); }
        .action-button.cancel-rename:hover { color: var(--neutral-800); }
        .rename-controls { display: inline-flex; align-items: center; gap: 0.5rem; max-width: calc(100% - 80px); margin-left: 0.5rem; }
        .rename-controls input.rename-input { flex-grow: 1; font-size: 0.9em; padding: 0.3rem 0.5rem; }
        .rename-controls .action-button { margin-left: 0.1rem; }
        .loader { border: 3px solid rgba(255,255,255,0.3); border-top: 3px solid white; border-radius: 50%; width: 18px; height: 18px; animation: spin 1s linear infinite; display: none; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .info { background-color: var(--info-light); color: var(--info-dark); border-left: 4px solid var(--primary); padding: 1rem; border-radius: var(--radius-sm); margin-bottom: 1.5rem; text-align: left; font-size: 0.95rem; }
        .info i { vertical-align: middle; margin: 0 0.1em; }
        .result-display-area { margin-top: 1.5rem; padding: 1.5rem; background-color: white; border-radius: var(--radius); border: 1px solid var(--neutral-200); text-align: left; word-wrap: break-word; display: none; font-size: 0.95em; min-height: 100px; box-shadow: var(--shadow-sm); transition: all 0.3s ease; }
        .result-display-area.error { background-color: var(--danger-light); color: var(--danger); border-left: 4px solid var(--danger); }
        .result-display-area strong.title { display: block; margin-bottom: 0.75rem; color: var(--primary); font-weight: 600; font-size: 1.1rem; border-bottom: 1px solid var(--neutral-200); padding-bottom: 0.75rem; }
        .result-display-area.error strong.title { color: var(--danger); }
        .result-display-area pre { background-color: var(--neutral-50); padding: 1rem; border-radius: var(--radius-sm); border: 1px solid var(--neutral-200); font-family: Monaco, Menlo, Consolas, "Liberation Mono", monospace; white-space: pre-wrap; word-break: break-all; font-size: 0.9rem; margin: 0; color: var(--neutral-800); overflow-x: auto; max-height: 400px; overflow-y: auto; }
        .result-display-area.error pre { color: var(--danger); background-color: transparent; border: none; padding: 0; white-space: pre-wrap; font-family: inherit; font-size: 1em; }
        #historyList { list-style: none; padding: 0; max-height: 300px; overflow-y: auto; border: 1px solid var(--neutral-200); border-radius: var(--radius); margin-bottom: 1rem; background-color: white; }
        #historyList li { padding: 0.75rem 1rem; border-bottom: 1px solid var(--neutral-200); cursor: pointer; font-size: 0.9rem; display: flex; justify-content: space-between; align-items: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; transition: background-color 0.2s ease; color: var(--neutral-700); }
        #historyList li:last-child { border-bottom: none; }
        #historyList li:hover { background-color: var(--neutral-100); }
        #historyList li.selected { background-color: var(--primary-light); color: var(--primary-dark); font-weight: 500; border-left: 4px solid var(--primary); }
        #historyList .action-button.delete-button { margin-left: auto; padding-left: 0.5rem; }
        .history-actions { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; gap: 0.75rem; }
        .history-actions button { margin-top: 0; padding: 0.75rem 1rem; font-size: 0.9rem; flex-shrink: 0; }
        #showAllButton { background-color: var(--success); display: flex; align-items: center; gap: 0.5rem; }
        #showAllButton:hover { background-color: #0d9488; }
        #clearHistoryButton { background-color: var(--danger); display: flex; align-items: center; gap: 0.5rem; }
        #clearHistoryButton:hover { background-color: #b91c1c; }
        #urlTreeContainer { font-size: 0.95rem; border: 1px solid var(--neutral-200); padding: 1.5rem; border-radius: var(--radius); max-height: 500px; overflow: auto; background-color: white; box-shadow: var(--shadow-sm); }
        #urlTreeContainer ul { list-style: none; padding-left: 1.5rem; margin-top: 0.5rem; }
        #urlTreeContainer li { margin-bottom: 0.5rem; position: relative; }
        .toggle-icon { cursor: pointer; margin-right: 0.5rem; width: 1em; display: inline-block; text-align: center; }
        #urlTreeContainer li::before { content: ""; position: absolute; left: -1rem; top: 0.7rem; width: 0.5rem; height: 0; border-top: 1px solid var(--neutral-300); }
        #urlTreeContainer ul > li::after { content: ""; position: absolute; left: -1rem; top: 0; height: 100%; border-left: 1px solid var(--neutral-300); }
        #urlTreeContainer ul > li:last-child::after { height: 0.7rem; }
        #urlTreeContainer .category-label { font-weight: 600; color: var(--neutral-700); display: inline-flex; align-items: center; margin-bottom: 0.3rem; padding: 0.25rem 0.5rem; position: relative; width: 100%; border-radius: var(--radius-sm); transition: background-color 0.2s ease, border 0.2s ease; border: 1px solid transparent; }
        #urlTreeContainer .category-label > .label-text, #urlTreeContainer .category-label .folder-icon { pointer-events: none; }
        #urlTreeContainer .category-label > .label-text { margin-right: 5px; }
        #urlTreeContainer .category-label.drag-over { background-color: var(--primary-light); border: 1px dashed var(--primary); }
        .category-actions { margin-left: auto; display: inline-flex; align-items: center; }
        #urlTreeContainer .category-label .folder-icon { margin-right: 0.5rem; color: var(--primary); }
        #urlTreeContainer .url-link { display: flex; justify-content: space-between; align-items: center; padding: 0.25rem 0.5rem; border-radius: var(--radius-sm); transition: opacity 0.2s ease; cursor: grab; }
        #urlTreeContainer .url-link.dragging { opacity: 0.5; cursor: grabbing; background-color: var(--neutral-200); }
        #urlTreeContainer .url-link a {
            color: var(--primary);
            text-decoration: none;
            word-break: break-all;
            font-size: 0.9rem;
            display: inline-flex;
            align-items: center;
            margin-right: 5px;
        }
        #urlTreeContainer .empty-tree { font-style: italic; color: var(--neutral-500); text-align: center; padding: 2rem; }
        .hidden { display: none !important; }
        @media (max-width: 768px) { .main-wrapper { border-radius: var(--radius); } .page-content { padding: 1.25rem; } #urlTreeContainer .category-label > .label-text { max-width: calc(100% - 120px); /* Adjusted for 3 buttons */ overflow: hidden; text-overflow: ellipsis; white-space: nowrap; display: inline-block; } #urlTreeContainer .url-link a { max-width: calc(100% - 40px); } }
        @media (max-width: 600px) { body { padding: 10px; } h1 { font-size: 1.5rem; padding: 1rem 0; } .tab-button { padding: 0.75rem 0.5rem; font-size: 0.85rem; } .tab-container { padding: 0; } .tab-button i { margin-right: 0; } .tab-button span { display: none; } .history-actions { flex-direction: column; } .history-actions button { width: 100%; } #urlTreeContainer ul { padding-left: 1rem; } .result-display-area pre { font-size: 0.8rem; } .rename-controls { width: calc(100% - 20px); } #urlTreeContainer .category-label > .label-text { max-width: calc(100% - 140px); /* Adjusted */ } #urlTreeContainer .url-link a { max-width: calc(100% - 50px); } }

    </style>
</head>
<body>
    <div class="main-wrapper">
        <h1>Web Page Classifier</h1>

        <!-- Tab Navigation -->
        <div class="tab-container">
            <button class="tab-button active" data-target="classifierPage"> <i class="fas fa-magnifying-glass"></i> <span>Classifier</span> </button>
            <button class="tab-button" data-target="historyPage"> <i class="fas fa-clock-rotate-left"></i> <span>History</span> </button>
            <button class="tab-button" data-target="treePage"> <i class="fas fa-sitemap"></i> <span>URL Tree</span> </button>
        </div>

        <!-- Classifier Page Content -->
        <div id="classifierPage" class="page-content active">
             <div class="info"> <i class="fas fa-circle-info"></i> Enter a URL. The classification result (JSON) will be displayed below and saved to history using organizational heuristics. </div>
            <div class="form-group"> <label for="pageUrl">Web Page URL:</label> <input type="url" id="pageUrl" placeholder="https://example.com/article" required> </div>
            <button id="classifyButton"> <div class="loader" id="loader"></div> <span>Classify URL</span> </button>
            <div id="classifierResultDisplay" class="result-display-area"> <strong class="title">API Result (Raw):</strong> <pre></pre> </div>
        </div>

        <!-- History Page Content -->
        <div id="historyPage" class="page-content">
            <h2>Classification History List</h2>
            <ul id="historyList"><li></li></ul>
            <div class="history-actions">
                <button id="showAllButton"> <i class="fas fa-list"></i> <span>Show All URLs & Classifications</span> </button>
                <button id="clearHistoryButton"> <i class="fas fa-trash-can"></i> <span>Clear History</span> </button>
            </div>
            <div id="historyResultDisplay" class="result-display-area"> <strong class="title">Selected / All History:</strong> <pre></pre> </div>
        </div>

        <!-- Tree Page Content -->
        <div id="treePage" class="page-content">
            <h2>URL Classification Tree</h2>
            <div class="info">
                 <i class="fas fa-circle-info"></i> Drag URL (<i class="fas fa-link"></i>) to move.
                 Click <i class="fas fa-chevron-down"></i>/<i class="fas fa-chevron-right"></i> to toggle.
                 Click <i class="fas fa-pencil-alt"></i> to rename folder.
                 Click <i class="fas fa-folder-plus"></i> to add subfolder.
                 Click <i class="fas fa-trash-alt"></i> on folder/URL to delete.
            </div>
            <div id="urlTreeContainer">
                <!-- Tree will be rendered here by JavaScript -->
            </div>
        </div>

    </div> <!-- End main-wrapper -->

    <script>
        // --- Configuration ---
        const NETLIFY_FUNCTION_ENDPOINT = '/.netlify/functions/classify-url';
        const LOCAL_STORAGE_KEY = 'urlClassificationHistory';
        const DRAG_DATA_TYPE = 'text/plain';
        const DUMMY_ITEM_PREFIX = 'placeholder://dummy_';
        const MAX_ITEMS_PER_CATEGORY = 8;
        const MIN_KEYWORD_LENGTH = 4;
        const STOP_WORDS = new Set(['the', 'a', 'an', 'and', 'or', 'but', 'is', 'are', 'was', 'were', 'in', 'on', 'at', 'to', 'for', 'with', 'of', 'it', 'this', 'that', 'from', 'by', 'as', 'new', 'news', 'web', 'site', 'page', 'com', 'org', 'net', 'html', 'http', 'https']);

        // --- DOM Elements ---
        const classifyButton = document.getElementById('classifyButton');
        const urlInput = document.getElementById('pageUrl');
        const loader = document.getElementById('loader');
        const buttonText = classifyButton.querySelector('span');
        const classifierResultDisplay = document.getElementById('classifierResultDisplay');
        const historyResultDisplay = document.getElementById('historyResultDisplay');
        const historyList = document.getElementById('historyList');
        const clearHistoryButton = document.getElementById('clearHistoryButton');
        const showAllButton = document.getElementById('showAllButton');
        const urlTreeContainer = document.getElementById('urlTreeContainer');
        const tabButtons = document.querySelectorAll('.tab-button');
        const pageContents = document.querySelectorAll('.page-content');

        // --- State ---
        let classificationHistory = [];
        let draggedElement = null;

        // --- Helper: Generate Unique ID ---
        function generateId(isDummy = false) { /* ... no changes ... */
            const randomPart = Math.random().toString(36).substring(2);
            return isDummy ? DUMMY_ITEM_PREFIX + randomPart : Date.now().toString(36) + randomPart;
        }

        // --- Functions ---

        function showLoading(isLoading) { /* ... no changes ... */
             if (isLoading) {
                classifyButton.disabled = true;
                loader.style.display = 'inline-block';
                buttonText.textContent = 'Classifying...';
                classifierResultDisplay.classList.remove('error');
            } else {
                classifyButton.disabled = false;
                loader.style.display = 'none';
                buttonText.textContent = 'Classify URL';
            }
        }
        function displayResultInArea(areaElement, data, isError = false, titlePrefix = 'Result') { /* ... no changes ... */
             areaElement.innerHTML = '';
            areaElement.style.display = 'block';
            const title = document.createElement('strong');
            title.classList.add('title');
            const resultOutput = document.createElement('pre');
            if (isError) {
                areaElement.classList.add('error');
                title.textContent = `Error:`;
                resultOutput.textContent = (typeof data === 'string') ? data : JSON.stringify(data, null, 2);
            } else {
                areaElement.classList.remove('error');
                title.textContent = `${titlePrefix}:`;
                resultOutput.textContent = JSON.stringify(data, null, 2);
            }
            areaElement.appendChild(title);
            areaElement.appendChild(resultOutput);
        }

        // Delete an entry from history by id
        function deleteHistoryEntryById(entryId) { /* ... no changes ... */
              const initialLength = classificationHistory.length;
            classificationHistory = classificationHistory.filter(entry => entry.id !== entryId);
            if (classificationHistory.length < initialLength) {
                saveHistory();
                renderHistoryList();
                const treeData = buildUrlTree(classificationHistory);
                renderTree(treeData, urlTreeContainer);
                 historyResultDisplay.style.display = 'none';
                 document.querySelectorAll('#historyList li.selected').forEach(el => el.classList.remove('selected'));
                 console.log(`Deleted history entry ${entryId}`);
            } else {
                console.warn(`Attempted to delete non-existent entry ${entryId}`);
            }
        }

        // --- History List Rendering and Management ---

        function renderHistoryList() { /* ... no changes ... */
             historyList.innerHTML = '';
            const nonDummyHistory = classificationHistory.filter(item => !item.id.startsWith(DUMMY_ITEM_PREFIX));

            if (nonDummyHistory.length === 0) {
                const emptyLi = document.createElement('li');
                emptyLi.textContent = "No history yet.";
                emptyLi.style.fontStyle = "italic";
                emptyLi.style.color = "var(--neutral-500)";
                emptyLi.style.textAlign = "center";
                emptyLi.style.cursor = "default";
                historyList.appendChild(emptyLi);
                return;
            }

            nonDummyHistory.forEach((item) => {
                const li = document.createElement('li');
                const textSpan = document.createElement('span');
                textSpan.textContent = item.url;
                textSpan.style.overflow = 'hidden';
                textSpan.style.textOverflow = 'ellipsis';
                textSpan.style.whiteSpace = 'nowrap';
                textSpan.title = item.url;
                li.appendChild(textSpan);
                li.dataset.id = item.id;
                const delBtn = document.createElement('button');
                delBtn.classList.add('action-button', 'delete-button');
                delBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
                delBtn.title = "Delete this entry";
                delBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteHistoryEntryById(item.id);
                });
                li.appendChild(delBtn);
                li.addEventListener('click', () => {
                    document.querySelectorAll('#historyList li.selected').forEach(el => el.classList.remove('selected'));
                    li.classList.add('selected');
                    if (item.classification) {
                        displayResultInArea(historyResultDisplay, item.classification, false, `Selected: ${item.url}`);
                    } else {
                        displayResultInArea(historyResultDisplay, "Classification data missing for this entry.", true, `Selected: ${item.url}`);
                    }
                });
                historyList.appendChild(li);
            });
        }
        function loadHistory() { /* ... no changes ... */
             try {
                const storedHistory = localStorage.getItem(LOCAL_STORAGE_KEY);
                classificationHistory = storedHistory ? JSON.parse(storedHistory) : [];
                 if (!Array.isArray(classificationHistory)) {
                     console.warn("Stored history was not an array, resetting.");
                     classificationHistory = [];
                     localStorage.removeItem(LOCAL_STORAGE_KEY);
                 }
            } catch (error) {
                console.error("Error loading/parsing history:", error);
                classificationHistory = [];
            }
            renderHistoryList();
            const treeData = buildUrlTree(classificationHistory);
            renderTree(treeData, urlTreeContainer);
        }
        function saveHistory() { /* ... no changes ... */
              try {
                const validHistory = classificationHistory.filter(item => item && item.id);
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(validHistory));
                classificationHistory = validHistory;
            } catch (error) {
                console.error("Error saving history:", error);
                displayResultInArea(classifierResultDisplay, "Could not save history (Storage might be full).", true);
            }
        }
        function addHistoryEntry(url, rawClassificationData) { /* ... no changes needed ... */
             if (!rawClassificationData || !rawClassificationData.classification) {
                console.error("Invalid classification data received, cannot add to history.", rawClassificationData);
                return;
            }
            const classificationData = JSON.parse(JSON.stringify(rawClassificationData));
            const proposedClassification = classificationData.classification;
            const optimalPath = determineOptimalPath(proposedClassification, classificationHistory);
            proposedClassification.url_type = optimalPath.urlType;
            proposedClassification.content_format = optimalPath.format;
            proposedClassification.content_type_hierarchy = [...optimalPath.hierarchy];
            const newItemKeywords = proposedClassification.keywords || [];
            const finalHierarchy = checkAndSubcategorizeIfNeeded(optimalPath, classificationHistory, newItemKeywords);
            proposedClassification.content_type_hierarchy = finalHierarchy;
            const newEntry = {
                id: generateId(),
                url: url,
                classification: classificationData
            };
            classificationHistory.unshift(newEntry);
            console.log(`Added entry ${newEntry.id} with final path: [${optimalPath.urlType}/${optimalPath.format}]/[${finalHierarchy.join('/')}]`);
            saveHistory();
            renderHistoryList();
            const treeData = buildUrlTree(classificationHistory);
            renderTree(treeData, urlTreeContainer);
        }
        function showAllHistory() { /* ... no changes ... */
             const nonDummyHistory = classificationHistory.filter(item => !item.id.startsWith(DUMMY_ITEM_PREFIX));
            if (nonDummyHistory.length === 0) {
                displayResultInArea(historyResultDisplay, "History is empty.", true, "Full History");
            } else {
                 const displayHistory = nonDummyHistory.map(({ id, ...rest }) => rest);
                 displayResultInArea(historyResultDisplay, displayHistory, false, "All Stored Classifications");
            }
            document.querySelectorAll('#historyList li.selected').forEach(el => el.classList.remove('selected'));
        }
        function clearHistory() { /* ... no changes ... */
             if (confirm("Are you sure you want to clear the entire classification history? This cannot be undone.")) {
                classificationHistory = [];
                saveHistory();
                renderHistoryList();
                historyResultDisplay.style.display = 'none';
                urlTreeContainer.innerHTML = '<div class="empty-tree">History cleared.</div>';
            }
        }


        // --- Tree Building and Rendering Logic ---
        // ... (buildUrlTree remains exactly the same as the previous version) ...
        const get = (obj, path, defaultValue = undefined) => { /* ... no changes ... */
             const travel = (regexp) => String.prototype.split.call(path, regexp).filter(Boolean).reduce((res, key) => (res !== null && res !== undefined ? res[key] : res), obj); const result = travel(/[,[\]]+?/) || travel(/[,[\].]+?/); return result === undefined || result === obj ? defaultValue : result;
        };
        function buildUrlTree(history) { /* ... no changes needed ... */
             const tree = {}; // Root of the tree
            history.forEach(item => {
                if (!item || !item.id || !item.classification) return;
                const classification = get(item, 'classification.classification');
                if (!classification) return;
                const urlType = classification.url_type || 'Unknown Type';
                const format = classification.content_format || 'Unknown Format';
                const hierarchy = Array.isArray(classification.content_type_hierarchy) && classification.content_type_hierarchy.length > 0 ? classification.content_type_hierarchy : ['Unknown Category'];
                let currentLevel = tree;
                let parentMetaHierarchy = [];
                const metaUrlType = { urlType: urlType, format: null, hierarchy: [urlType] };
                if (!currentLevel[urlType]) currentLevel[urlType] = { _meta: metaUrlType };
                else if (!currentLevel[urlType]._meta) currentLevel[urlType]._meta = metaUrlType;
                parentMetaHierarchy = currentLevel[urlType]._meta.hierarchy;
                currentLevel = currentLevel[urlType];
                let formatKey = format;
                let actualFormatForMeta = format;
                let formatSkipped = false;
                if (format.trim().toLowerCase() !== 'html') {
                    const metaFormat = { urlType: urlType, format: actualFormatForMeta, hierarchy: [...parentMetaHierarchy, formatKey] };
                    if (!currentLevel[formatKey]) currentLevel[formatKey] = { _meta: metaFormat };
                    else if (!currentLevel[formatKey]._meta) currentLevel[formatKey]._meta = metaFormat;
                    parentMetaHierarchy = currentLevel[formatKey]._meta.hierarchy;
                    currentLevel = currentLevel[formatKey];
                } else {
                    actualFormatForMeta = 'HTML';
                    formatSkipped = true;
                }
                hierarchy.forEach((category, index) => {
                    const isLastLevel = index === hierarchy.length - 1;
                    const currentMetaHierarchy = formatSkipped ? [urlType, ...hierarchy.slice(0, index + 1)] : [urlType, formatKey, ...hierarchy.slice(0, index + 1)];
                    const metaHierarchy = { urlType: urlType, format: actualFormatForMeta, hierarchy: currentMetaHierarchy };
                    if (!currentLevel[category]) {
                        currentLevel[category] = { _meta: metaHierarchy };
                        if (isLastLevel && !item.id.startsWith(DUMMY_ITEM_PREFIX)) { currentLevel[category]._items = []; }
                    } else if (!currentLevel[category]._meta) { currentLevel[category]._meta = metaHierarchy; }
                    if (isLastLevel && !item.id.startsWith(DUMMY_ITEM_PREFIX)) {
                        if (!currentLevel[category]._items) { currentLevel[category]._items = []; }
                        if (!currentLevel[category]._items.some(entry => entry.id === item.id)) { currentLevel[category]._items.push({ id: item.id, url: item.url }); }
                    }
                    if (!isLastLevel) { currentLevel = currentLevel[category]; }
                });
            });
            return tree;
        }

        // Modified renderTreeNode to add Delete Folder icon
        function renderTreeNode(node, parentUl) {
            const categories = Object.keys(node).filter(key => key !== '_meta' && key !== '_items').sort();

            categories.forEach(category => {
                const li = document.createElement('li');
                const nodeValue = node[category];
                const meta = nodeValue._meta;
                const items = nodeValue._items || [];

                const isFolder = Object.keys(nodeValue).some(k => k !== '_meta' && k !== '_items');
                const hasRealItems = items.some(item => !item.id.startsWith(DUMMY_ITEM_PREFIX));

                if (!meta) {
                    console.warn("Node missing _meta data:", category, nodeValue);
                    return;
                }

                // --- Create Header ---
                const header = document.createElement('div');
                header.classList.add('category-label');
                header.dataset.targetUrlType = meta.urlType;
                header.dataset.targetFormat = meta.format === null ? 'HTML' : meta.format;
                header.dataset.targetHierarchy = JSON.stringify(meta.hierarchy);

                // --- Left side: Toggle, Folder Icon, Label ---
                const toggleIcon = document.createElement('i');
                if (isFolder || items.length > 0) {
                   toggleIcon.classList.add('toggle-icon', 'fas', 'fa-chevron-right');
                } else {
                   toggleIcon.classList.add('toggle-icon', 'fas', 'fa-minus');
                   toggleIcon.style.opacity = '0.3';
                   toggleIcon.style.cursor = 'default';
                }
                const iconSpan = document.createElement('i');
                iconSpan.classList.add('fas', 'fa-folder', 'folder-icon');
                const labelSpan = document.createElement('span');
                labelSpan.classList.add('label-text');
                labelSpan.textContent = category;

                header.appendChild(toggleIcon);
                header.appendChild(iconSpan);
                header.appendChild(labelSpan);

                 // --- Right side: Action Buttons Container ---
                 const actionsContainer = document.createElement('div');
                 actionsContainer.classList.add('category-actions');

                 // Rename Icon
                 const renameIcon = document.createElement('button');
                 renameIcon.classList.add('action-button', 'rename-icon');
                 renameIcon.innerHTML = '<i class="fas fa-pencil-alt"></i>';
                 renameIcon.title = `Rename folder "${category}"`;
                 renameIcon.dataset.categoryName = category;
                 renameIcon.dataset.fullHierarchyPath = JSON.stringify(meta.hierarchy);
                 actionsContainer.appendChild(renameIcon);

                 // Create Subfolder Icon
                 const createFolderIcon = document.createElement('button');
                 createFolderIcon.classList.add('action-button', 'create-folder-icon');
                 createFolderIcon.innerHTML = '<i class="fas fa-folder-plus"></i>';
                 createFolderIcon.title = `Create subfolder in "${category}"`;
                 createFolderIcon.dataset.parentUrlType = meta.urlType;
                 createFolderIcon.dataset.parentFormat = meta.format === null ? 'HTML' : meta.format;
                 createFolderIcon.dataset.parentHierarchy = JSON.stringify(meta.hierarchy);
                 actionsContainer.appendChild(createFolderIcon);

                 // Delete Folder Icon (NEW)
                 const deleteFolderIcon = document.createElement('button');
                 deleteFolderIcon.classList.add('action-button', 'delete-folder-icon');
                 deleteFolderIcon.innerHTML = '<i class="fas fa-trash-can"></i>'; // Consistent trash icon
                 deleteFolderIcon.title = `Delete folder "${category}" and all its contents`;
                 deleteFolderIcon.dataset.targetHierarchy = JSON.stringify(meta.hierarchy); // Path to delete
                 actionsContainer.appendChild(deleteFolderIcon);


                 header.appendChild(actionsContainer);

                li.appendChild(header);

                // --- Create Nested List (ul) for Children ---
                let nestedUl = null;
                if (isFolder || items.length > 0) {
                    nestedUl = document.createElement('ul');
                    nestedUl.style.display = 'none';
                    if (isFolder) {
                        renderTreeNode(nodeValue, nestedUl);
                    }

                    items.filter(item => !item.id.startsWith(DUMMY_ITEM_PREFIX))
                         .sort((a, b) => a.url.localeCompare(b.url))
                         .forEach(entry => {
                             const urlLi = document.createElement('li');
                             urlLi.classList.add('url-link');
                             urlLi.draggable = true;
                             urlLi.dataset.entryId = entry.id;
                             const link = document.createElement('a');
                             link.href = entry.url;
                             link.target = '_blank';
                             link.rel = 'noopener noreferrer';
                             // Try to extract hostname and use a friendly name/icon
                             try {
                                 const urlObj = new URL(entry.url);
                                 const domain = urlObj.hostname;
                                 // Optional: use a mapping to give a friendlier name
                                 const friendlyNames = {
                                     "www.amazon.com": "Kindle",
                                     "amazon.com": "Kindle"
                                     // add more mappings if needed...
                                 };
                                 const displayName = friendlyNames[domain] || domain;
                                 // Use a favicon service to get the icon (Googleâ€™s favicon API)
                                 const faviconUrl = `https://www.google.com/s2/favicons?domain=${domain}`;
                                 // Set title to show full url on hover
                                 link.title = entry.url;
                                 // Build the link content: an image followed by display text
                                 link.innerHTML = `<img src="${faviconUrl}" alt="icon" style="vertical-align:middle; margin-right:4px;"> <span>${displayName}</span>`;
                             } catch (e) {
                                 // Fallback if URL parsing fails
                                 link.textContent = entry.url;
                                 link.title = entry.url;
                             }
                             urlLi.appendChild(link);
                             const deleteBtn = document.createElement('button');
                             deleteBtn.classList.add('action-button', 'delete-button');
                             deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
                             deleteBtn.title = "Delete this URL entry";
                             deleteBtn.addEventListener('click', (e) => {
                                 e.stopPropagation();
                                 deleteHistoryEntryById(entry.id);
                             });
                             urlLi.appendChild(deleteBtn);
                             nestedUl.appendChild(urlLi);
                         });
                     li.appendChild(nestedUl);

                     const toggle = () => {
                         const isHidden = nestedUl.style.display === 'none';
                         nestedUl.style.display = isHidden ? 'block' : 'none';
                         if (isHidden) {
                             toggleIcon.classList.replace('fa-chevron-right', 'fa-chevron-down');
                         } else {
                             toggleIcon.classList.replace('fa-chevron-down', 'fa-chevron-right');
                         }
                     };

                     toggleIcon.addEventListener('click', (e) => {
                         e.stopPropagation();
                         toggle();
                     });

                     labelSpan.style.cursor = 'pointer';
                     labelSpan.addEventListener('click', (e) => {
                         e.stopPropagation();
                         toggle();
                     });
                 }
                 parentUl.appendChild(li);
            });
        }

        function renderTree(treeData, containerElement) { /* ... no changes ... */
              containerElement.innerHTML = '';
            if (Object.keys(treeData).length === 0) {
                containerElement.innerHTML = '<div class="empty-tree">No classification data available to build the tree.</div>';
                return;
            }
            const rootUl = document.createElement('ul');
            containerElement.appendChild(rootUl);
            renderTreeNode(treeData, rootUl);
        }

        // --- Rename, Drag/Drop, Create Folder, Delete Folder Logic ---
        // ... (showRenameInput, handleRenameSave, handleRenameCancel remain the same) ...
        function showRenameInput(renameIcon) { /* ... no changes ... */
             const headerDiv = renameIcon.closest('.category-label'); const labelSpan = headerDiv.querySelector('.label-text'); const actionsContainer = headerDiv.querySelector('.category-actions'); const oldName = renameIcon.dataset.categoryName; if (headerDiv.querySelector('.rename-controls')) return; labelSpan.classList.add('hidden'); if (actionsContainer) actionsContainer.classList.add('hidden'); const input = document.createElement('input'); input.type = 'text'; input.value = oldName; input.classList.add('rename-input'); input.addEventListener('keydown', (e) => { if (e.key === 'Enter') { handleRenameSave(input); } else if (e.key === 'Escape') { handleRenameCancel(input); } }); const saveBtn = document.createElement('button'); saveBtn.classList.add('action-button', 'save-rename'); saveBtn.innerHTML = '<i class="fas fa-check"></i>'; saveBtn.title = 'Save new name'; saveBtn.addEventListener('click', () => handleRenameSave(input)); const cancelBtn = document.createElement('button'); cancelBtn.classList.add('action-button', 'cancel-rename'); cancelBtn.innerHTML = '<i class="fas fa-times"></i>'; cancelBtn.title = 'Cancel rename'; cancelBtn.addEventListener('click', () => handleRenameCancel(input)); const controls = document.createElement('div'); controls.classList.add('rename-controls'); controls.appendChild(input); controls.appendChild(saveBtn); controls.appendChild(cancelBtn); headerDiv.insertBefore(controls, labelSpan); input.focus(); input.select();
        }
        function handleRenameSave(inputElement) { /* ... no changes ... */
             const controlsDiv = inputElement.closest('.rename-controls'); if (!controlsDiv) return; const headerDiv = controlsDiv.closest('.category-label'); const actionsContainer = headerDiv.querySelector('.category-actions'); const renameIcon = actionsContainer?.querySelector('.rename-icon'); if (!renameIcon) { console.error("Could not find original rename icon data."); handleRenameCancel(inputElement); return; } const oldName = renameIcon.dataset.categoryName; const fullHierarchyPathString = renameIcon.dataset.fullHierarchyPath; const newName = inputElement.value.trim(); if (newName && newName !== oldName) { try { const fullHierarchyPath = JSON.parse(fullHierarchyPathString); if (renameCategoryInData(fullHierarchyPath, oldName, newName)) { console.log(`Renamed category based on path [${fullHierarchyPath.join('/')}] to "${newName}"`); const treeData = buildUrlTree(classificationHistory); renderTree(treeData, urlTreeContainer); } else { console.error("Rename function reported no changes made."); handleRenameCancel(inputElement); } } catch (e) { console.error("Error parsing path or renaming:", e); handleRenameCancel(inputElement); } } else { handleRenameCancel(inputElement); }
        }
        function handleRenameCancel(inputElement) { /* ... no changes ... */
            const controlsDiv = inputElement.closest('.rename-controls'); if (!controlsDiv) return; const headerDiv = controlsDiv.closest('.category-label'); const labelSpan = headerDiv.querySelector('.label-text'); const actionsContainer = headerDiv.querySelector('.category-actions'); controlsDiv.remove(); labelSpan.classList.remove('hidden'); if (actionsContainer) actionsContainer.classList.remove('hidden');
        }
        function renameCategoryInData(fullHierarchyPath, oldName, newName) { /* ... no changes ... */
            if (!fullHierarchyPath || fullHierarchyPath.length === 0 || !oldName || !newName || oldName === newName) { console.warn("Rename aborted: Invalid parameters."); return false; } let changesMade = false; const targetUrlType = fullHierarchyPath[0]; const hierarchyRenameIndex = fullHierarchyPath.length - 2; classificationHistory.forEach(item => { if (item.id.startsWith(DUMMY_ITEM_PREFIX)) return; const classification = get(item, 'classification.classification'); if (!classification) return; const itemUrlType = classification.url_type || 'Unknown Type'; const itemHierarchy = Array.isArray(classification.content_type_hierarchy) ? [...classification.content_type_hierarchy] : ['Unknown Category']; if (itemUrlType === targetUrlType) { if (itemHierarchy.length > hierarchyRenameIndex) { if (itemHierarchy[hierarchyRenameIndex] === oldName) { let prefixMatch = true; for (let i = 0; i < hierarchyRenameIndex; i++) { if (itemHierarchy[i] !== fullHierarchyPath[i + 1]) { prefixMatch = false; break; } } if (prefixMatch) { itemHierarchy[hierarchyRenameIndex] = newName; item.classification.classification.content_type_hierarchy = itemHierarchy; changesMade = true; } } } } }); if (changesMade) { /* Save handled by caller */ } else { console.warn("Rename function executed, but no matching history entries found/modified for path:", fullHierarchyPath); } return changesMade;
        }
        function moveHistoryEntry(entryId, targetUrlType, targetFormat, targetHierarchyArray) { /* ... no changes ... */
             if (!Array.isArray(targetHierarchyArray)) { console.error("Cannot move entry: targetHierarchy is not an array.", targetHierarchyArray); return false; } const entryIndex = classificationHistory.findIndex(item => item.id === entryId); if (entryIndex === -1) { console.error(`Cannot move entry: ID ${entryId} not found.`); return false; } const entry = classificationHistory[entryIndex]; let classification = get(entry, 'classification.classification'); if (!classification) { console.warn(`Creating classification structure for moved entry: ID ${entryId}.`); if (!entry.classification) entry.classification = {}; if (!entry.classification.classification) entry.classification.classification = {}; classification = entry.classification.classification; } let actualTargetHierarchy = []; let hierarchyStartIndex = 1; if (targetHierarchyArray.length > 1 && targetHierarchyArray[1] === targetFormat && targetFormat !== targetUrlType) { hierarchyStartIndex = 2; } actualTargetHierarchy = targetHierarchyArray.slice(hierarchyStartIndex); classification.url_type = targetUrlType; classification.content_format = targetFormat; classification.content_type_hierarchy = actualTargetHierarchy; console.log(`Moved entry ${entryId} to [${targetUrlType}/${targetFormat}]/[${actualTargetHierarchy.join('/')}]`); return true;
        }
        function handleCreateFolder(createIcon) { /* ... no changes ... */
            const parentUrlType = createIcon.dataset.parentUrlType; const parentFormat = createIcon.dataset.parentFormat; const parentHierarchyString = createIcon.dataset.parentHierarchy; if (!parentUrlType || !parentFormat || !parentHierarchyString) { console.error("Cannot create folder: Missing parent data on icon."); return; } const newFolderName = prompt("Enter name for the new subfolder:"); if (newFolderName && newFolderName.trim()) { const trimmedName = newFolderName.trim(); try { const parentHierarchyMetaPath = JSON.parse(parentHierarchyString); let parentHierarchyParts = []; let hierarchyStartIndex = 1; if (parentHierarchyMetaPath.length > 1 && parentHierarchyMetaPath[1] === parentFormat && parentFormat !== parentUrlType) { hierarchyStartIndex = 2; } parentHierarchyParts = parentHierarchyMetaPath.slice(hierarchyStartIndex); const newHierarchy = [...parentHierarchyParts, trimmedName]; const dummyEntry = { id: generateId(true), url: `${DUMMY_ITEM_PREFIX}${trimmedName}/${generateId()}`, classification: { classification: { url_type: parentUrlType, content_format: parentFormat, content_type_hierarchy: newHierarchy, primary_language: "Undetermined", keywords: [], confidence: "Low" } } }; console.log("Creating dummy entry:", dummyEntry); classificationHistory.push(dummyEntry); saveHistory(); const treeData = buildUrlTree(classificationHistory); renderTree(treeData, urlTreeContainer); } catch (e) { console.error("Error parsing parent hierarchy or creating folder:", e); alert("Failed to create folder due to an internal error."); } } else if (newFolderName !== null) { alert("Folder name cannot be empty."); }
        }

        // --- NEW: Delete Folder Data Logic ---
        function deleteFolderAndContents(folderPathToDelete) {
            if (!Array.isArray(folderPathToDelete) || folderPathToDelete.length === 0) {
                console.error("Invalid folder path provided for deletion.");
                return false;
            }

            const initialLength = classificationHistory.length;
            const pathLengthToDelete = folderPathToDelete.length;

            classificationHistory = classificationHistory.filter(item => {
                 if (!item || !item.classification || !item.classification.classification) {
                     return true; // Keep items with invalid structure? Or filter them? Let's keep them.
                 }
                 const classification = item.classification.classification;
                 const itemUrlType = classification.url_type || 'Unknown Type';
                 const itemFormat = classification.content_format || 'Unknown Format';
                 const itemHierarchy = Array.isArray(classification.content_type_hierarchy) ? classification.content_type_hierarchy : ['Unknown Category'];

                 // Reconstruct the item's full conceptual path for comparison
                 const itemFullPath = [itemUrlType];
                 if (itemFormat.trim().toLowerCase() !== 'html') {
                     itemFullPath.push(itemFormat);
                 }
                 itemFullPath.push(...itemHierarchy);

                 // Check if the item's path starts with the folder path to delete
                 if (itemFullPath.length < pathLengthToDelete) {
                     return true; // Item path is shorter, cannot be inside the folder
                 }

                 // Check prefix match
                 let isInsideFolder = true;
                 for (let i = 0; i < pathLengthToDelete; i++) {
                     if (itemFullPath[i] !== folderPathToDelete[i]) {
                         isInsideFolder = false;
                         break;
                     }
                 }

                 // Keep the item ONLY if it's NOT inside the folder being deleted
                 return !isInsideFolder;
            });

            const finalLength = classificationHistory.length;
            const deletedCount = initialLength - finalLength;

            if (deletedCount > 0) {
                console.log(`Deleted ${deletedCount} item(s) under path [${folderPathToDelete.join('/')}]`);
                return true; // Indicate changes were made
            } else {
                console.log(`No items found to delete under path [${folderPathToDelete.join('/')}]`);
                return false; // No changes made
            }
        }


        // --- Path Optimization & Subcategorization Logic ---
        // ... (determineOptimalPath, checkAndSubcategorizeIfNeeded, getCommonPrefixLength remain the same) ...
        function getCommonPrefixLength(h1, h2) { /* ... no changes ... */
             let len = 0; const maxLen = Math.min(h1.length, h2.length); for (let i = 0; i < maxLen; i++) { if (h1[i] === h2[i]) { len++; } else { break; } } return len;
        }
        function determineOptimalPath(proposedClassification, history) { /* ... no changes ... */
            const pUrlType = proposedClassification.url_type || 'Unknown Type'; const pFormat = proposedClassification.content_format || 'Unknown Format'; const pHierarchy = Array.isArray(proposedClassification.content_type_hierarchy) ? proposedClassification.content_type_hierarchy : ['Unknown Category']; let bestMatch = { urlType: pUrlType, format: pFormat, hierarchy: [...pHierarchy], score: -1 }; let perfectMatchFound = false; const nonDummyHistory = history.filter(item => !item.id.startsWith(DUMMY_ITEM_PREFIX)); for (const item of nonDummyHistory) { const existingClassification = get(item, 'classification.classification'); if (!existingClassification) continue; const eUrlType = existingClassification.url_type || 'Unknown Type'; const eFormat = existingClassification.content_format || 'Unknown Format'; const eHierarchy = Array.isArray(existingClassification.content_type_hierarchy) ? existingClassification.content_type_hierarchy : ['Unknown Category']; let currentScore = 0; let commonPrefixLen = 0; if (eUrlType === pUrlType) { currentScore += 1; if (eFormat === pFormat) { currentScore += 1; commonPrefixLen = getCommonPrefixLength(eHierarchy, pHierarchy); currentScore += commonPrefixLen; } if (eFormat === pFormat && eHierarchy.length === pHierarchy.length && commonPrefixLen === pHierarchy.length) { console.log("Found perfect path match:", { urlType: eUrlType, format: eFormat, hierarchy: eHierarchy }); perfectMatchFound = true; bestMatch = { urlType: eUrlType, format: eFormat, hierarchy: [...eHierarchy], score: Infinity }; break; } if (currentScore > bestMatch.score) { bestMatch = { urlType: eUrlType, format: eFormat, hierarchy: [...eHierarchy], score: currentScore, commonPrefixLen: commonPrefixLen }; } } } if (perfectMatchFound) { return { urlType: bestMatch.urlType, format: bestMatch.format, hierarchy: bestMatch.hierarchy }; } else if (bestMatch.score >= 2) { const commonPrefix = bestMatch.hierarchy.slice(0, bestMatch.commonPrefixLen); const remainingProposed = pHierarchy.slice(bestMatch.commonPrefixLen); const finalHierarchy = [...commonPrefix, ...remainingProposed]; console.log("Using partial match. Common:", commonPrefix, "Remaining proposed:", remainingProposed); const finalFormat = bestMatch.format; return { urlType: bestMatch.urlType, format: finalFormat, hierarchy: finalHierarchy }; } else { console.log("No suitable existing path found, using proposed path."); return { urlType: pUrlType, format: pFormat, hierarchy: pHierarchy }; }
        }
        function checkAndSubcategorizeIfNeeded(targetPath, history, newItemKeywords) { /* ... no changes ... */
             const { urlType, format, hierarchy } = targetPath; let finalHierarchy = [...hierarchy]; const matchingItemsIndices = []; const matchingItemsKeywords = []; history.forEach((item, index) => { if (item.id.startsWith(DUMMY_ITEM_PREFIX)) return; const itemClass = get(item, 'classification.classification'); if (itemClass && (itemClass.url_type || 'Unknown Type') === urlType && (itemClass.content_format || 'Unknown Format') === format && Array.isArray(itemClass.content_type_hierarchy) && itemClass.content_type_hierarchy.length === hierarchy.length && itemClass.content_type_hierarchy.every((h, i) => h === hierarchy[i])) { matchingItemsIndices.push(index); matchingItemsKeywords.push(...(itemClass.keywords || [])); } }); const currentCount = matchingItemsIndices.length; const totalCount = currentCount + 1; console.log(`Checking subcategorization for path [${urlType}/${format}]/[${hierarchy.join('/')}]: ${currentCount} existing + 1 new = ${totalCount}. Threshold: ${MAX_ITEMS_PER_CATEGORY}`); if (totalCount >= MAX_ITEMS_PER_CATEGORY) { console.log("Threshold met, attempting subcategorization..."); const allKeywords = [...matchingItemsKeywords, ...newItemKeywords]; const keywordCounts = {}; allKeywords.forEach(kw => { if (typeof kw === 'string') { const cleanedKw = kw.trim().toLowerCase(); if (cleanedKw.length >= MIN_KEYWORD_LENGTH && !STOP_WORDS.has(cleanedKw)) { keywordCounts[cleanedKw] = (keywordCounts[cleanedKw] || 0) + 1; } } }); let bestKeyword = null; let maxCount = 0; for (const [kw, count] of Object.entries(keywordCounts)) { if (count > maxCount && count > 1) { maxCount = count; bestKeyword = kw; } } if (!bestKeyword && Object.keys(keywordCounts).length > 0) { for (const [kw, count] of Object.entries(keywordCounts)) { if (count > maxCount) { maxCount = count; bestKeyword = kw; } } } if (bestKeyword) { const subCategoryName = bestKeyword.charAt(0).toUpperCase() + bestKeyword.slice(1); const newHierarchy = [...hierarchy, subCategoryName]; console.log(`Found subcategory keyword: "${subCategoryName}". New hierarchy:`, newHierarchy); matchingItemsIndices.forEach(index => { const itemToModify = classificationHistory[index]; if (itemToModify && itemToModify.classification && itemToModify.classification.classification) { itemToModify.classification.classification.content_type_hierarchy = [...newHierarchy]; console.log(`Updated existing item ${itemToModify.id} to new subcategory.`); } }); finalHierarchy = newHierarchy; } else { console.log("Could not determine a suitable keyword for subcategorization."); finalHierarchy = hierarchy; } } return finalHierarchy;
        }


        // --- Tab Switching Logic ---
        function switchTab(event) { /* ... no changes ... */
              if (draggedElement) { draggedElement.classList.remove('dragging'); draggedElement = null; } document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over')); const targetId = event.currentTarget.dataset.target; tabButtons.forEach(button => { button.classList.toggle('active', button.dataset.target === targetId); }); pageContents.forEach(page => { page.classList.toggle('active', page.id === targetId); }); if (targetId === 'treePage') { const treeData = buildUrlTree(classificationHistory); renderTree(treeData, urlTreeContainer); }
        }

        // --- Main Classification Function ---
        async function classifyUrlContent() { /* ... no changes ... */
             const pageUrl = urlInput.value.trim(); if (!pageUrl || !/^https?:\/\/.+/.test(pageUrl)) { displayResultInArea(classifierResultDisplay, "Please enter a valid URL (starting with http:// or https://).", true, "Input Error"); return; } showLoading(true); displayResultInArea(classifierResultDisplay, `Requesting classification for ${pageUrl}...`, false, "API Request Pending"); try { const response = await fetch(NETLIFY_FUNCTION_ENDPOINT, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ url: pageUrl }) }); const data = await response.json(); if (!response.ok) { throw new Error(data.error || `Function Error: ${response.status} ${response.statusText}`); } if (data.classification && typeof data.classification === 'object' && data.classification.classification) { displayResultInArea(classifierResultDisplay, data.classification, false, 'API Result (Raw)'); addHistoryEntry(pageUrl, data.classification); } else { console.warn("Received unexpected response format:", data); throw new Error("Received an unexpected response format from the classification service."); } } catch (error) { console.error("Error during classification:", error); displayResultInArea(classifierResultDisplay, `Classification failed: ${error.message}`, true, "Classification Error"); } finally { showLoading(false); }
        }

        // --- Initialization and Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            loadHistory();

            // Tab switching
            tabButtons.forEach(button => button.addEventListener('click', switchTab));

            // Classifier action
            classifyButton.addEventListener('click', classifyUrlContent);
            urlInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') { event.preventDefault(); classifyUrlContent(); }
            });

            // History actions
            clearHistoryButton.addEventListener('click', clearHistory);
            showAllButton.addEventListener('click', showAllHistory);

            // --- Event delegation for tree actions ---
            urlTreeContainer.addEventListener('click', (event) => {
                 // Handle Rename Icon Clicks
                 const renameIcon = event.target.closest('.rename-icon');
                 if (renameIcon) {
                      event.stopPropagation();
                      showRenameInput(renameIcon);
                      return;
                 }
                 // Handle Create Folder Icon Clicks
                  const createFolderIcon = event.target.closest('.create-folder-icon');
                  if (createFolderIcon) {
                      event.stopPropagation();
                      handleCreateFolder(createFolderIcon);
                      return;
                  }
                  // Handle Delete Folder Icon Clicks (NEW)
                   const deleteFolderIcon = event.target.closest('.delete-folder-icon');
                   if (deleteFolderIcon) {
                       event.stopPropagation();
                       const hierarchyString = deleteFolderIcon.dataset.targetHierarchy;
                       const folderName = JSON.parse(hierarchyString).pop() || 'this folder'; // Get last part for message
                       if (confirm(`Are you sure you want to delete the folder "${folderName}" and ALL its contents? This cannot be undone.`)) {
                           try {
                               const folderPath = JSON.parse(hierarchyString);
                               if (deleteFolderAndContents(folderPath)) {
                                   // Data updated, now save and re-render
                                   saveHistory();
                                   renderHistoryList(); // Update history list view
                                   const treeData = buildUrlTree(classificationHistory);
                                   renderTree(treeData, urlTreeContainer);
                               }
                           } catch (e) {
                               console.error("Error parsing folder path for deletion:", e);
                               alert("Error deleting folder.");
                           }
                       }
                       return; // Processed delete click
                   }
            });

            // --- Drag and Drop Event Listeners (Delegated) ---
            urlTreeContainer.addEventListener('dragstart', (event) => { /* ... no changes ... */
                 const targetLi = event.target.closest('li.url-link'); if (targetLi && targetLi.draggable) { draggedElement = targetLi; const entryId = targetLi.dataset.entryId; event.dataTransfer.setData(DRAG_DATA_TYPE, entryId); event.dataTransfer.effectAllowed = 'move'; setTimeout(() => { targetLi.classList.add('dragging'); }, 0); }
            });
            urlTreeContainer.addEventListener('dragend', (event) => { /* ... no changes ... */
                 if (draggedElement) { draggedElement.classList.remove('dragging'); draggedElement = null; document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over')); }
            });
            urlTreeContainer.addEventListener('dragover', (event) => { /* ... no changes ... */
                 const dropTarget = event.target.closest('.category-label'); if (dropTarget && draggedElement) { event.preventDefault(); event.dataTransfer.dropEffect = 'move'; dropTarget.classList.add('drag-over'); }
            });
             urlTreeContainer.addEventListener('dragleave', (event) => { /* ... no changes ... */
                 const dropTarget = event.target.closest('.category-label'); if (dropTarget) { dropTarget.classList.remove('drag-over'); }
            });
             urlTreeContainer.addEventListener('drop', (event) => { /* ... no changes ... */
                 event.preventDefault(); const dropTarget = event.target.closest('.category-label'); if (dropTarget && draggedElement) { dropTarget.classList.remove('drag-over'); const entryId = event.dataTransfer.getData(DRAG_DATA_TYPE); const targetUrlType = dropTarget.dataset.targetUrlType; const targetFormat = dropTarget.dataset.targetFormat; const targetHierarchyString = dropTarget.dataset.targetHierarchy; if (entryId && targetUrlType && targetFormat && targetHierarchyString) { try { const targetHierarchyArray = JSON.parse(targetHierarchyString); if (moveHistoryEntry(entryId, targetUrlType, targetFormat, targetHierarchyArray)) { saveHistory(); const treeData = buildUrlTree(classificationHistory); renderTree(treeData, urlTreeContainer); } else { console.error("Failed to move history entry in data."); } } catch (e) { console.error("Drop failed: Error parsing target hierarchy.", e); } } else { console.error("Drop failed: Missing data from dragged item or drop target.", { entryId, targetUrlType, targetFormat, targetHierarchyString }); } } if (draggedElement) { draggedElement.classList.remove('dragging'); draggedElement = null; }
             });


            // Ensure default tab content is shown
            document.querySelector('.page-content.active') || document.getElementById('classifierPage').classList.add('active');
            document.querySelector('.tab-button.active') || document.querySelector('.tab-button[data-target="classifierPage"]').classList.add('active');
        });

    </script>
</body>
</html>